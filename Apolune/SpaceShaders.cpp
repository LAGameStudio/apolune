#include "SpaceShaders.h"

WaterAndGroundShader waterandgroundShader;

void ShadedWaterAndGround( FBOColor *out, WaterAndGroundProfile *in ) {
 out->Bind();
 waterandgroundShader.Set(in);
 out->QuadYInverted(&waterandgroundShader);
 out->Unbind();
}

EmissionCloudsShader emissioncloudsShader;

void ShadedEmissionClouds( FBOColor *out, EmissionCloudsProfile *in ) {
 out->Bind();
 emissioncloudsShader.Set(in);
 out->QuadYInverted(&emissioncloudsShader);
 out->Unbind();
}

ElectroCloudsShader electrocloudsShader;

void ShadedElectroClouds( FBOColor *out, ElectroCloudsProfile *in ) {
 out->Bind();
 electrocloudsShader.Set(in);
 out->QuadYInverted(&electrocloudsShader);
 out->Unbind();
}

NebulazShader nebulazShader;

void ShadedNebulaz( FBOColor *out, NebulazProfile *in ) {
 out->Bind();
 nebulazShader.Set(in);
 out->QuadYInverted(&nebulazShader);
 out->Unbind();
}

ToonTroidShader toontroidShader;

void ShadedToonTroid( FBOColor *out, ToonTroidProfile *in ) {
 out->Bind();
 toontroidShader.Set(in);
 out->QuadYInverted(&toontroidShader);
 out->Unbind();
}

TexturedPlanetShader texturedplanetShader;

void ShadedTexturedPlanet( FBOColor *out, TexturedPlanetProfile *in ) {
 out->Bind();
 texturedplanetShader.Set(in);
 out->QuadYInverted(&texturedplanetShader);
 out->Unbind();
}

EarthlikeShader earthlikeShader;

void ShadedEarthlike( FBOColor *out, EarthlikeProfile *in ) {
 out->Bind();
 earthlikeShader.Set(in);
 out->QuadYInverted(&earthlikeShader);
 out->Unbind();
}

AccretionShader accretionShader;

void ShadedAccretion( FBOColor *out, AccretionProfile *in ) {
 out->Bind();
 accretionShader.Set(in);
 out->QuadYInverted(&accretionShader);
 out->Unbind();
}

BlackHoleShader blackholeShader;

void ShadedBlackHole( FBOColor *out, BlackHoleProfile *in ) {
 out->Bind();
 blackholeShader.Set(in);
 out->QuadYInverted(&blackholeShader);
 out->Unbind();
}

RingedJovianShader ringedjovianShader;

void ShadedRingedJovian( FBOColor *out, RingedJovianProfile *in ) {
 out->Bind();
 ringedjovianShader.Set(in);
 out->QuadYInverted(&ringedjovianShader);
 out->Unbind();
}

ElectroPlanetShader electroplanetShader;

void ShadedElectroPlanet( FBOColor *out, ElectroPlanetProfile *in ) {
 out->Bind();
 electroplanetShader.Set(in);
 out->QuadYInverted(&electroplanetShader);
 out->Unbind();
}

AtmosphericPlanetShader atmosphericplanetShader;

void ShadedAtmosphericPlanet( FBOColor *out, AtmosphericPlanetProfile *in ) {
 out->Bind();
 atmosphericplanetShader.Set(in);
 out->QuadYInverted(&atmosphericplanetShader);
 out->Unbind();
}

Earthlike2Shader earthlike2Shader;

void ShadedEarthlike2( FBOColor *out, Earthlike2Profile *in ) {
 out->Bind();
 earthlike2Shader.Set(in);
 out->QuadYInverted(&earthlike2Shader);
 out->Unbind();
}

RingedJovian2Shader ringedjovian2Shader;

void ShadedRingedJovian2( FBOColor *out, RingedJovian2Profile *in ) {
 out->Bind();
 ringedjovian2Shader.Set(in);
 out->QuadYInverted(&ringedjovian2Shader);
 out->Unbind();
}

LunarPlanetShader lunarplanetShader;

void LunarPlanetShader::Render( FBOColor *out, LunarPlanetProfile *in ) {
 out->Bind();
 lunarplanetShader.Set(in);
 out->QuadYInverted(&lunarplanetShader);
 out->Unbind();
}

void ShadedLunarPlanet( FBOColor *out, LunarPlanetProfile *in ) {
 out->Bind();
 lunarplanetShader.Set(in);
 out->QuadYInverted(&lunarplanetShader);
 out->Unbind();
}



FlaringStarShader flaringstarShader;

void FlaringStarShader::Render( FBOColor *out, FlaringStarProfile *in ) {
 out->Bind();
 flaringstarShader.Set(in);
 out->QuadYInverted(&flaringstarShader);
 out->Unbind();
}

void ShadedFlaringStar( FBOColor *out, FlaringStarProfile *in ) {
 out->Bind();
 flaringstarShader.Set(in);
 out->QuadYInverted(&flaringstarShader);
 out->Unbind();
}


ElectronCloudsShader electroncloudsShader;

void ElectronCloudsShader::Render( FBOColor *out, ElectronCloudsProfile *in ) {
 out->Bind();
 electroncloudsShader.Set(in);
 out->QuadYInverted(&electroncloudsShader);
 out->Unbind();
}

void ShadedElectronClouds( FBOColor *out, ElectronCloudsProfile *in ) {
 out->Bind();
 electroncloudsShader.Set(in);
 out->QuadYInverted(&electroncloudsShader);
 out->Unbind();
}

ClassicPlanetShader classicplanetShader;

void ClassicPlanetShader::Render( FBOColor *out, ClassicPlanetProfile *in ) {
 out->Bind();
 classicplanetShader.Set(in);
 out->QuadYInverted(&classicplanetShader);
 out->Unbind();
}

void ShadedClassicPlanet( FBOColor *out, ClassicPlanetProfile *in ) {
 out->Bind();
 classicplanetShader.Set(in);
 out->QuadYInverted(&classicplanetShader);
 out->Unbind();
}

/////////////////////////////////////////// Shaders


 void WaterAndGroundShader::Init() {
  OUTPUT("WaterAndGroundShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec4 waveParams;  // = vec4(0.5,4.,6.,.5) largeH,largeSz,smallH,smallSz\n")
   +string("uniform vec2 waterLight;  // = vec2(15.,120.)  range 1-200, x < y, x=soft,y=glossy factors\n")
   +string("uniform float particleAmount; // = 70.\n")
   +string("uniform vec3 waterColor1;  // = vec3(0.43,0.6,0.66)  transparent low-water color RGB1\n")
   +string("uniform vec3 waterColor2;  // = vec3(0.06,0.07,0.11)  RGB1\n")
   +string("uniform vec3 waterSpec;    // = vec3(1.3,1.3,0.9)     Water Specular Factor\n")
   +string("uniform vec3 light;        // = vec3(0,20,10); // light position : vec3(-0., sin(iGlobalTime*0.5)*.5 + .35, 2.8); // position of the sun\n")
   +string("uniform sampler2D noiseTex;\n")
   +string("uniform sampler2D groundTex;\n")
   +string("uniform vec3 landColor;   // vec3(0.7, 0.55, 0.4) \n")
   +string("uniform vec2 pos2d;        // 0-1.0 normalized Position 2d vector\n")
   +string("uniform vec4 LEVEL;        // = 0.525,0.54,0.5,0.1 threshold of what is considered flat / coast, water level, deep water level, coastalFade 0.0-2.0\n")
   +string("uniform float time;        // time (global time)\n")
   +string("float hash( float n )\n")
   +string("{\n")
   +string(" return fract(sin(n)*43758.5453123);\n")
   +string("}\n")
   +string("float noise1( in vec2 x )\n")
   +string("{\n")
   +string(" vec2 p  = floor(x);\n")
   +string(" vec2 f  = smoothstep(0.0, 1.0, fract(x));\n")
   +string(" float n = p.x + p.y*57.0;\n")
   +string(" return mix( mix( hash(n+  0.0), hash(n+  1.0),f.x), mix(hash(n+ 57.0), hash(n+ 58.0), f.x ), f.y);\n")
   +string("}\n")
   +string("float noise(vec2 p)\n")
   +string("{\n")
   +string(" return texture2D(noiseTex,p*vec2(1.0/256.0)).x;\n")
   +string("}\n")
   +string("float height_map( vec2 p )\n")
   +string("{\n")
   +string("  mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\n")
   +string("  p = p+ pos2d*10.0;\n")
   +string("  p = p*6.;\n")
   +string("  float f = 0.6000*noise1( p );\n")
   +string("  p = m*p*1.1;\n")
   +string("  f += 0.2500*noise1( p );\n")
   +string("  p = m*p*1.32;\n")
   +string("  f += 0.1666*noise1( p );\n")
   +string("  p = m*p*1.11;\n")
   +string("  f += 0.0834*noise( p );\n")
   +string("  p = m*p*1.12;\n")
   +string("  f += 0.0634*noise( p );\n")
   +string("  p = m*p*1.13;\n")
   +string("  f += 0.0444*noise( p );\n")
   +string("  p = m*p*1.14;\n")
   +string("  f += 0.0274*noise( p );\n")
   +string("  p = m*p*1.15;\n")
   +string("  f += 0.0134*noise( p );\n")
   +string("  p = m*p*1.16;\n")
   +string("  f += 0.0104*noise( p );\n")
   +string("  p = m*p*1.17;\n")
   +string("  f += 0.0084*noise( p );\n")
   +string("  if (f<LEVEL.x)\n")
   +string("      f = f;\n")
   +string("  else\n")
   +string("      f = pow((f-LEVEL.x)/(1.-LEVEL.x), 2.)*(1.-LEVEL.x)*2.0+LEVEL.x; // makes a smooth coast-increase\n")
   +string("  return clamp(f, 0., 10.);\n")
   +string("}\n")
   +string("vec3 terrain_map( vec2 p )\n")
   +string("{\n")
   +string("  p = p+ pos2d*10.0;\n")
   +string("  return landColor+texture2D(groundTex, p*2.0).rgb*0.5; // test-terrain is simply 'sandstone'\n")
   +string("}\n")
   +string("const mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\n")
   +string("float water_map( vec2 p, float height )\n")
   +string("{\n")
   +string("  p = p+ pos2d*120.0;\n")
   +string("  vec2 p2 = p*waveParams.y;\n")
   +string("  vec2 shift1 = 0.001*vec2( time*160.0*2.0, time*120.0*2.0 );\n")
   +string("  vec2 shift2 = 0.001*vec2( time*190.0*2.0, -time*130.0*2.0 );\n")
   +string("\n")
   +string("  // coarse crossing 'ocean' waves...\n")
   +string("  float f = 0.6000*noise( p );\n")
   +string("  f += 0.2500*noise( p*m );\n")
   +string("  f += 0.1666*noise( p*m*m );\n")
   +string("  float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*waveParams.x*f*height*height ;\n")
   +string("\n")
   +string("  p *= waveParams.w;\n")
   +string("  f = 0.;\n")
   +string("  float amp = 1.0;\n")
   +string("  float s = 0.5;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string("  p = m * p * 0.947;\n")
   +string("  f -= amp*abs(sin((noise( p+shift1*s )-0.5)*2.0));\n")
   +string("  amp = amp*0.59;\n")
   +string("  s*=-1.329;\n")
   +string(" \n")
   +string("  return wave+f*waveParams.z;\n")
   +string("}\n")
   +string("\n")
   +string("float nautic(vec2 p)\n")
   +string("{\n")
   +string("  p = p+ pos2d*10.0;\n")
   +string("  p *= 18.0;\n")
   +string("  float f = 0.0;\n")
   +string("  float amp = 1.0;\n")
   +string("  float s = 0.5;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*abs(smoothstep(0.0, 1.0, noise( p+time*s ))-0.5);\n")
   +string("  amp = amp * 0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*abs(smoothstep(0.0, 1.0, noise( p+time*s ))-0.5);\n")
   +string("  amp = amp * 0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*abs(smoothstep(0.0, 1.0, noise( p+time*s ))-0.5);\n")
   +string("  amp = amp * 0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*abs(smoothstep(0.0, 1.0, noise( p+time*s ))-0.5);\n")
   +string("  amp = amp * 0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  return pow(1.0-f, 5.0);\n")
   +string("}\n")
   +string("\n")
   +string("float particles(vec2 p)\n")
   +string("{\n")
   +string("  p = p+ vec2(-pos2d.x,pos2d.y);\n")
   +string("  p *= 200.;\n")
   +string("  float f = 0.;\n")
   +string("  float amp = 1.0;\n")
   +string("  float s = 1.5;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*noise( p+time*s );\n")
   +string("  amp = amp*0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*noise( p+time*s );\n")
   +string("  amp = amp*0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*noise( p+time*s );\n")
   +string("  amp = amp*0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  p = m * p * 1.2;\n")
   +string("  f += amp*noise( p+time*s );\n")
   +string("  amp = amp*0.5;\n")
   +string("  s*=-1.227;\n")
   +string("  return pow(f*0.35, 7.0)*particleAmount;\n")
   +string("}\n")
   +string("\n")
   +string("\n")
   +string("float test_shadow( vec2 xy, float height)\n")
   +string("{\n")
   +string("    vec3 r0 = vec3(xy, height);\n")
   +string("    vec3 rd = normalize( light - r0 );\n")
   +string("    \n")
   +string("    float hit = 1.0;\n")
   +string("    float t   = 0.001;\n")
   +string("    for (int j=1; j<25; j++)\n")
   +string("    {\n")
   +string("        vec3 p = r0 + t*rd;\n")
   +string("        float h = height_map( p.xy );\n")
   +string("        float height_diff = p.z - h;\n")
   +string("        if (height_diff<0.0)\n")
   +string("        {\n")
   +string("            return 0.0;\n")
   +string("        }\n")
   +string("        t += 0.01+height_diff*.02;\n")
   +string("        hit = min(hit, 2.0*height_diff/t); // soft shaddow   \n")
   +string("    }\n")
   +string("    return hit;\n")
   +string("}\n")
   +string("\n")
   +string("vec3 CalcTerrain(vec2 uv, float height)\n")
   +string("{\n")
   +string("  vec3 col = terrain_map( uv );\n")
   +string("  float h1 = height_map(uv-vec2(0.0, 0.01));\n")
   +string("  float h2 = height_map(uv+vec2(0.0, 0.01));\n")
   +string("  float h3 = height_map(uv-vec2(0.01, 0.0));\n")
   +string("  float h4 = height_map(uv+vec2(0.01, 0.0));\n")
   +string("  vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.0));\n")
   +string("  vec3 r0 = vec3(uv, height);\n")
   +string("  vec3 rd = normalize( light - r0 );\n")
   +string("  float grad = dot(norm, rd);\n")
   +string("  col *= grad+pow(grad, 8.0);\n")
   +string("  float terrainshade = test_shadow( uv, height );\n")
   +string("  col = mix(col*0.25, col, terrainshade);\n")
   +string("  return col;\n")
   +string("}\n")
   +string("\n")
   +string("\n")
   +string("void main() {\n")
   +string("	vec2 uv =(Texcoord.xy*vec2(2.0,1.0) + vec2(1.0,0.0)) + pos2d - vec2(-0.12, +0.25);\n")
   +string("    float deepwater_fadedepth   = LEVEL.z + LEVEL.w;\n")
   +string("    float height = height_map( uv );\n")
   +string("    vec3 col = vec3(0.0,0.0,0.0);\n")
   +string("    float waveheight = clamp(LEVEL.y*3.0-1.5, 0.0, 1.0);\n")
   +string("    float level = LEVEL.y + 0.2*water_map(uv*15.0 + vec2(time*0.1), waveheight);\n")
   +string("    if (height > level)\n")
   +string("    {\n")
   +string("        col = CalcTerrain(uv, height);\n")
   +string("    }\n")
   +string("    if (height <= level)\n")
   +string("    {\n")
   +string("        vec2 dif = vec2(0.0, 0.01);\n")
   +string("        vec2 pos = uv*15. + vec2(time*0.01);\n")
   +string("        float h1 = water_map(pos-dif,waveheight);\n")
   +string("        float h2 = water_map(pos+dif,waveheight);\n")
   +string("        float h3 = water_map(pos-dif.yx,waveheight);\n")
   +string("        float h4 = water_map(pos+dif.yx,waveheight);\n")
   +string("        vec3 normwater = normalize(vec3(h3-h4, h1-h2, 0.125)); // norm-vector of the 'bumpy' water-plane\n")
   +string("        uv += normwater.xy*.002*(level-height);\n")
   +string("        col = CalcTerrain(uv, height);\n")
   +string("        float coastfade = clamp((level-height)/LEVEL.w, 0.0, 1.0);\n")
   +string("        float coastfade2= clamp((level-height)/LEVEL.z, 0.0, 1.0);\n")
   +string("        float intensity = col.r*0.2126+col.g*0.7152+col.b*0.0722;\n")
   +string("		vec3 watercolor = waterColor1;\n")
   +string("        watercolor = mix(watercolor*intensity, waterColor2, smoothstep(0.0, 1.0, coastfade2));\n")
   +string("        vec3 r0 = vec3(uv, LEVEL.y);\n")
   +string("        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\n")
   +string("        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\n")
   +string("        float specular = pow(grad, waterLight.x);  // used for soft highlights                          \n")
   +string("        float specular2= pow(grad, waterLight.y); // used for glossy highlights\n")
   +string("        float gradpos  = dot(vec3(0.0, 0.0, 1.0), rd);\n")
   +string("        float specular1= smoothstep(0.0, 1.0, pow(gradpos, 5.0));  // used for diffusity (some darker corona around light's specular reflections...)                          \n")
   +string("        float wshade  = test_shadow( uv, level );\n")
   +string("        watercolor *= 2.2+wshade;\n")
   +string("   		watercolor += (0.2+0.8*wshade) * ((grad-1.0)*0.5+specular) * 0.25;\n")
   +string("   		watercolor /= (1.0+specular1*1.25);\n")
   +string("   		watercolor += wshade*specular2*waterSpec;\n")
   +string("        watercolor += wshade*coastfade*(1.0-coastfade2)*(vec3(0.5, 0.6, 0.7)*nautic(uv)+vec3(1.0, 1.0, 1.0)*particles(uv));\n")
   +string("        col = mix(col, watercolor, coastfade);\n")
   +string("    }\n")
   +string("	outColor = vec4(col, 1.0);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }

 
 void EmissionCloudsShader::Init() {
  OUTPUT("EmissionClouds::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec2 pos2d;\n")
   +string("uniform float time;\n")
   +string("uniform sampler2D noiseTex;\n")
   +string("const int MAX_RAY_STEPS = 64;\n")
   +string("float noise( vec3 x )\n")
   +string("{\n")
   +string(" vec3 p = floor(x);\n")
   +string(" vec3 f = fract(x);\n")
   +string(" f = f*f*(3.0-2.0*f);\n")
   +string(" vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n")
   +string(" vec2 rg = texture2D( noiseTex, (uv+ 0.5)/512.0, -100.0 ).yx;\n")
   +string(" return -1.0+2.0*mix( rg.x, rg.y, f.z );\n")
   +string("}\n")
   +string("void main() {\n")
   +string(" vec2 screenPos = Texcoord.xy * 2.0 - 1.0;\n")
   +string(" vec3 cameraDir = vec3(0.0, 0.0, 1.4);\n")
   +string(" vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n")
   +string(" vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0);\n")
   +string(" vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n")
   +string(" vec3 rayPos = vec3(pos2d, 0.0);\n")
   +string(" rayDir = normalize(rayDir);\n")
   +string(" float dis = 0.0;\n")
   +string(" float t1 = 2.0;\n")
   +string(" vec3 dir = vec3(0.0,1.0,0.0);\n")
   +string(" float val;\n")
   +string(" vec3 col = vec3(0);\n")
   +string(" for(int i=0;i<MAX_RAY_STEPS;i++){\n")
   +string("  vec3 q = rayPos - dir * t1;\n")
   +string("  val  = 0.50000 * noise( q * 0.05 );\n")
   +string("  q = q*2.0 - dir * t1;\n")
   +string("  val += 0.25000 * noise( q * 0.05  );\n")
   +string("  q = q*2.0 - dir * t1;\n")
   +string("  val += 0.12500 * noise( q * 0.05  );\n")
   +string("  q = q*2.0 - dir * t1;\n")
   +string("  val += 0.06250 * noise( q * 0.05  );\n")
   +string("  q = q*2.5 - dir * t1;\n")
   +string("  val += 0.03125 * noise( q * 0.8  );\n")
   +string("  float t = max(5.0 * val - 0.9, 0.0);\n")
   +string("  col += sqrt(dis) * 0.1 * vec3(0.5 * t * t * t, 0.6 * t * t, 0.7 * t);\n")
   +string("  dis += 1.0 / float(MAX_RAY_STEPS);\n")
   +string("  rayPos += rayDir * 1.0/ (0.4);\n")
   +string(" }\n")
   +string(" col = min(col, 1.0) - 0.34 * (log(col + 1.0));\n")
   +string(" outColor = vec4(sqrt(col.rgb), 1.0);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void ElectroCloudsShader::Init() {
  OUTPUT("ElectroCloudsShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform float time;\n")
   +string("uniform sampler2D noiseTex;\n")
   +string("uniform vec2 pos;\n")
   +string("uniform float toffs;        // = -154.0;\n")
   +string("uniform float complexity;   // 10 - 100\n")
   +string("uniform vec3 tint;\n")
   +string("// Nebula Clouds\n")
   +string("vec4 noise(float p){return texture2D(noiseTex,vec2(p*float(1.0/256.0),.0));}\n")
   +string("vec4 noise(vec2 p){return texture2D(noiseTex,p*vec2(1.0/256.0));}\n")
   +string("vec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture2D(noiseTex,p.xy*vec2(1.0/256.0) + noise(sprev).yz*21.421),texture2D(noiseTex,p.xy*vec2(1.0/256.0) + noise(s).yz*14.751),m);}\n")
   +string("vec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),	noise(p.xyz+noise(s).wyx*4521.5314),	m);}\n")
   +string("mat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\n")
   +string("mat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.0,0.0,0.0,    0.0,ca,sa,   0.0,-sa,ca);}\n")
   +string("mat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,0.0,sa,    0.0,1.0,0.0,   -sa,0.0,ca);}\n")
   +string("mat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);}\n")
   +string("float density(vec3 p) {	vec4 d = noise(p*0.5)*noise(p.xz*0.044)*noise(p.xy*0.26)*noise(p.yz*0.21);float fd = dot(d,vec4(1.4));fd = fd*fd*fd*fd*fd;return max(0.0,fd);}\n")
   +string("void main() {\n")
   +string("    float t = time + noise(Texcoord.xy).y/(24.0-24.0/(time+1.0)) + toffs;\n")
   +string("    vec2 uv = pos.xy + Texcoord.xy -vec2(0.9,0.5);\n")
   +string("	vec2 m = Texcoord.xy;\n")
   +string("	//rotation matrix for the camera\n")
   +string("	mat3 rotmat = rotate_y((t-toffs)*.07)*rotate_x((t-toffs)*.031);\n")
   +string("	//p is ray position\n")
   +string("	vec3 p = vec3(0.0,0.0,-30.0); p*=rotmat;\n")
   +string("	p += vec3(sin(t),cos(t),sin(t*0.25)*29.0+t*7.0-22.0-4.0/((t-toffs)*0.01+0.01));\n")
   +string("	//d is ray direction\n")
   +string("	vec3 d = normalize(vec3(uv*(sin(t*0.17)*02+0.8),1.0-length(uv)*0.2));\n")
   +string("	d*=rotmat;\n")
   +string("	p+=d*noise(Texcoord.xy).x*0.9;\n")
   +string("	//some accumulators\n")
   +string("	float a = 0.0;\n")
   +string("	float ai = 0.0;\n")
   +string("	vec3 color = vec3(0.0);\n")
   +string("	for (float i=0.0; i<complexity; i += 1.0)\n")
   +string("	{\n")
   +string("		p+=d*0.9;\n")
   +string("		vec3 n = noise(p.xz*0.25+vec2(t*0.1)).xyz*12.0*noise(p.zy*0.1+vec2(t*0.1)).xyz;\n")
   +string("		float de = density(p+n);\n")
   +string("		a += de; // a is alpha, as the ray traverses the density function the\n")
   +string("		a = min(1.0,a); //a > 1.0 makes no sence and produces bugs\n")
   +string("		vec4 c2 = noise(p.yz*0.03).xyzw;\n")
   +string("		vec3 c = c2.xyz*1.7;\n")
   +string("		//lame illumiation\n")
   +string("		float occ = min((de-density(p+vec3(0.7+n))),1.0);\n")
   +string("		//occ = min(occ,(de-density(p+vec3(3.7)+n)));\n")
   +string("		//occ = min(occ,(de-density(p+vec3(5.7)+n)));\n")
   +string("		color += max(.0,occ)*(1.0-a)*c;\n")
   +string("		if (a>1.0) break;\n")
   +string("	}\n")
   +string("	color +=noise(uv).xyz*0.08;\n")
   +string("	color -= length(uv)*0.12;\n")
   +string("	color = max(vec3(0.0),color);\n")
   +string("	color  = mix(color,vec3(length(color)),length(color)*1.7-0.4);\n")
   +string("	color  = pow(color,vec3(0.6));\n")
   +string("	color *= 1.0+1.0/(t-toffs+0.01);\n")
   +string("	color *= tint;\n")
   +string("	outColor = vec4(color,(color.r,color.g,color.b)/3.0);\n")
   +string("}\n")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }



 
 void NebulazShader::Init() {
  OUTPUT("NebulazShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec2 pos2d;\n")
   +string("uniform sampler2D noiseTex;\n")
   +string("uniform vec3 blueColor;   //= vec3(0.635, 0.827, 0.996);\n")
   +string("uniform vec3 yellowColor; //= vec3(1.000, 0.823, 0.459);\n")
   +string("uniform vec3 redColor;    //= vec3(0.945, 0.584, 0.502);\n")
   +string("uniform vec3 orangeColor; //= vec3(0.553, 0.231, 0.086);\n")
   +string("uniform vec3 brownColor;  //= vec3(0.360, 0.137, 0.062);\n")
   +string("uniform vec3 blackColor;  //= vec3(0.095, 0.023, 0.043);\n")
   +string("uniform vec3 coolestColor; // = vec3(0.615, 0.706, 1.000);\n")
   +string("uniform vec3 middleColor;  // = vec3(0.984, 0.972, 1.000);\n")
   +string("uniform vec3 hottestColor; // = vec3(1.000, 0.733, 0.482);\n")
   +string("uniform float structure_size; //= 1.9;\n")
   +string("uniform float background_radiation1; // = 0.2;\n")
   +string("uniform float time; // = 0.2;\n")
   +string("const int drift_count = 5; // decrease for more fps\n")
   +string("const float step_size = 0.23; // increase for more fps\n")
   +string("const float pi = 3.1415926;\n")
   +string("const float field_of_view = 1.4;\n")
   +string("const float camera_radius = 7.0;\n")
   +string("const float nebula_radius = 6.0;\n")
   +string("float noise3d(vec3 x) {\n")
   +string("    vec3 p = floor(x);\n")
   +string("    vec3 f = fract(x);\n")
   +string("    f = f*f*(3.0-2.0*f);\n")
   +string("    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n")
   +string("    vec2 rg = texture2D(noiseTex, (uv + 0.5)/256.0, -100.0).xy;\n")
   +string("    return mix(rg.y, rg.x, f.z);\n")
   +string("}\n")
   +string("vec2 noise3d2(vec3 x) {\n")
   +string("    vec3 p = floor(x);\n")
   +string("    vec3 f = fract(x);\n")
   +string("    f = f*f*(3.0-2.0*f);\n")
   +string("    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n")
   +string("    vec4 rg = texture2D(noiseTex, (uv + 0.5)/256.0, -100.0);\n")
   +string("    return vec2(mix(rg.y, rg.x, f.z), mix(rg.w, rg.z, f.z));\n")
   +string("}\n")
   +string("\n")
   +string("float fbm3d_low(vec3 x) {\n")
   +string("    float f = 0.0;\n")
   +string("    f += 0.50000*noise3d(x); x = x*2.01;\n")
   +string("    f += 0.25000*noise3d(x); x = x*2.02;\n")
   +string("    f += 0.12500*noise3d(x); x = x*2.03;\n")
   +string("    f += 0.06250*noise3d(x);\n")
   +string("    return f;\n")
   +string("}\n")
   +string("float fbm3d(vec3 x) {\n")
   +string("    float f = 0.0;\n")
   +string("    f += 0.50000*noise3d(x); x = x*2.01;\n")
   +string("    f += 0.25000*noise3d(x); x = x*2.02;\n")
   +string("    f += 0.12500*noise3d(x); x = x*2.03;\n")
   +string("    f += 0.06250*noise3d(x); x = x*2.04;\n")
   +string("    f += 0.03125*noise3d(x); x = x*2.01;\n")
   +string("    f += 0.01562*noise3d(x);\n")
   +string("    return f;\n")
   +string("}\n")
   +string("vec4 noise3d4_discontinuous(vec3 x) {\n")
   +string("    vec3 p = floor(x);\n")
   +string("    vec3 f = fract(x);\n")
   +string("    f = f*f*(3.0-2.0*f);\n")
   +string("    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n")
   +string("    return texture2D(noiseTex, (uv + 0.5)/256.0, -100.0);\n")
   +string("}\n")
   +string("vec4 noise2d4(vec2 x) {\n")
   +string("    vec2 p = floor(x);\n")
   +string("    vec2 f = fract(x);\n")
   +string("    f = f*f*(3.0-2.0*f);\n")
   +string("    return texture2D(noiseTex, (p + f + 0.5)/256.0, -100.0);\n")
   +string("}\n")
   +string("vec3 star_color(float n) {\n")
   +string("    // based on: http://www.vendian.org/mncharity/dir3/starcolor/ \n")
   +string("    // constant distribution and linear interpolation\n")
   +string("    return mix(mix(coolestColor, middleColor, smoothstep(0.0, 0.5, n)),\n")
   +string("               mix(middleColor, hottestColor, smoothstep(0.5, 1.0, n)), step(0.5, n));\n")
   +string("}\n")
   +string("vec3 only_mix(vec3 src, vec3 dst, float start, float end, float amount) {\n")
   +string("    return mix(src, dst, smoothstep(start, end, amount)) * step(start, amount) * step(-end, -amount);\n")
   +string("}\n")
   +string("vec3 nebula_color(float noise) {\n")
   +string("    // colors sampled from the Keyhole Nebula\n")
   +string("    // https://commons.wikimedia.org/wiki/File:Keyhole_Nebula_-_Hubble_1999.jpg#/media/File:Keyhole_Nebula_-_Hubble_1999.jpg \n")
   +string("    noise = clamp(noise, 0.0, 1.0);\n")
   +string("    return max(max(max(max(\n")
   +string("           only_mix(blueColor, yellowColor, 0.0, 0.4, noise),\n")
   +string("           only_mix(yellowColor,  redColor, 0.4, 0.5, noise)),\n")
   +string("           only_mix(redColor,  orangeColor, 0.5, 0.7, noise)),\n")
   +string("           only_mix(orangeColor,brownColor, 0.7, 0.8, noise)),\n")
   +string("           only_mix(brownColor, blackColor, 0.8, 1.0, noise));\n")
   +string("}\n")
   +string("float star_brightness = 0.0;\n")
   +string("vec3 star_pos = vec3(0.0,0.0,0.0);\n")
   +string("vec3 star_field( vec3 x, float grid_size ) {\n")
   +string("    // a tiled randomly positioned dot, looks like stars.\n")
   +string("    vec3 grid = floor(x * grid_size);\n")
   +string("    vec3 pos = fract(x * grid_size);\n")
   +string("    vec4 noise = noise3d4_discontinuous(grid);\n")
   +string("    vec3 center = noise.xxy * 0.5 + 0.25;\n")
   +string("    vec3 to_center = center - pos;\n")
   +string("    vec3 out_of_plane = x * dot(to_center, x);\n")
   +string("    float len = length(to_center - out_of_plane);\n")
   +string("    float brightness = noise.w;\n")
   +string("    float radius = mix(0.003, 0.009, pow(brightness, 9.0)) * grid_size;\n")
   +string("    float show = step(0.8, noise.y);\n")
   +string("    \n")
   +string("    star_pos = (grid + center) / grid_size;\n")
   +string("    star_brightness = show * brightness;\n")
   +string("    return 2.0 * star_color(noise.z) * show * smoothstep(radius, 0.0, len);\n")
   +string("}\n")
   +string("vec2 screen_space(vec3 x, vec3 vx, vec3 vy, vec3 vz) {\n")
   +string("    vec3 rescaled = field_of_view / dot(vz, x) * x;\n")
   +string("    return vec2(dot(vx, rescaled), dot(vy, rescaled));\n")
   +string("}\n")
   +string("vec3 lens_flare(vec2 x, vec2 center, float brightness) {\n")
   +string("    // renders a lens flare at center\n")
   +string("    // quantization might be unnecessary, it prevents flickering\n")
   +string("    const float quantization = 500.0;\n")
   +string("    const float flare_size = 0.5;\n")
   +string("    vec2 to_x = (floor((x - center) * quantization) + 0.5) / quantization;\n")
   +string("    float shape = max(0.0, 0.005 / pow(abs(to_x.x * to_x.y), flare_size) - 0.3);\n")
   +string("    float radial_fade = smoothstep(0.04, 0.0, length(to_x));\n")
   +string("    float brightness_fade = smoothstep(0.75, 1.0, brightness);\n")
   +string("    return vec3(1.0) * shape * radial_fade * brightness_fade;\n")
   +string("}\n")
   +string("vec3 haze(vec3 x, vec3 background) {\n")
   +string("    // add grainy star background (illusion of infinite stars)\n")
   +string("    float base_structure = fbm3d_low(x * structure_size);\n")
   +string("    float star_structure = mix(smoothstep(0.35, 0.8, base_structure), 1.0, background_radiation1);\n")
   +string("    vec3 haze_color = 3.0 * vec3(0.058, 0.047, 0.096);\n")
   +string("    float grain = mix(2.0, 2.0*noise3d(x * 800.0), 0.5);\n")
   +string("    vec3 haze = haze_color * grain * smoothstep(0.1, 0.9, base_structure);\n")
   +string("    return star_structure * background + haze;\n")
   +string("}\n")
   +string("vec3 drift_field(vec3 x) {\n")
   +string("    // provide a velocity field to drift the nebula (makes it streaky)\n")
   +string("    // generate a divergence free field to make it look like fluid flow\n")
   +string("    x = x * pi / nebula_radius;\n")
   +string("    vec3 outwards = normalize(x) * 0.2;\n")
   +string("    vec3 div_free = vec3(0.0);\n")
   +string("    div_free += 0.50*sin(1.00*x+7.85).yzx;\n")
   +string("    div_free += 0.25*cos(2.48*x+6.13).zxy;\n")
   +string("    div_free += 0.12*cos(4.12*x+11.49).yzx;\n")
   +string("    div_free += 0.06*sin(7.83*x+11.82).zxy;\n")
   +string("    return outwards + div_free;\n")
   +string("}\n")
   +string("vec3 direction = vec3(0.0,0.0,0.0);\n")
   +string("vec3 drift(vec3 x, float speed ) {\n")
   +string("    // drift backwards in time to sample the original nebula\n")
   +string("    // keep the last velocity to help sample velocity aligned noise\n")
   +string("    direction = drift_field(x);\n")
   +string("    x -= direction * speed;\n")
   +string("    for(int i=0; i<drift_count-1; i++) {\n")
   +string("    	x -= drift_field(x) * speed;\n")
   +string("    }\n")
   +string("    return x;\n")
   +string("}\n")
   +string("vec4 nebula(vec3 x) {\n")
   +string("    // opacity via fbm\n")
   +string("    float drift_speed = 0.2 * noise3d(x * 0.5 + 1.24);\n")
   +string("    vec3 x_drifted = drift(x, drift_speed) * 0.7;\n")
   +string("    float density = 0.01 + 0.2 * smoothstep(0.50, 0.90, fbm3d(x_drifted + 23.6));\n")
   +string("    float radial_fade = smoothstep(nebula_radius, nebula_radius * 0.7, length(x));\n")
   +string("    // color via mix of global noise and drift aligned noise\n")
   +string("    float color_noise = noise3d(x_drifted);\n")
   +string("    float aligned_noise = noise3d(10.0 * (x - dot(x, normalize(direction))));\n")
   +string("    float noise = mix(color_noise, aligned_noise, 0.1);\n")
   +string("    float brightness = 0.1 * 0.9 + smoothstep(0.0, 1.0, noise);\n")
   +string("    vec3 color = mix(1.0, brightness, 0.7) * nebula_color(1.0 - noise);\n")
   +string("    \n")
   +string("    return vec4(color, radial_fade * density);\n")
   +string("}\n")
   +string("vec4 ray_trace(vec3 origin, vec3 ray) {\n")
   +string("    const float loop_max = 0.5 * 1.5 * nebula_radius + camera_radius;\n")
   +string("    const float fudge_factor = 2.1;\n")
   +string("    vec4 acc = vec4(0.0);\n")
   +string("    for(float i=0.0; i<loop_max; i+=step_size) {\n")
   +string("        vec3 pos = origin + i * ray;\n")
   +string("        vec4 sample = nebula(pos);\n")
   +string("        // TODO: accumulator is not step_size independent... why?\n")
   +string("        // TODO: remove the fudge factor exp(w * step_size)\n")
   +string("        acc = acc + (1.0 - acc.w) * vec4(sample.xyz * sample.w, sample.w);\n")
   +string("    }\n")
   +string("    acc.xyz *= fudge_factor;\n")
   +string("    return acc;\n")
   +string("}\n")
   +string("void main() {\n")
   +string("    vec2 pixel = -1.0 + 2.0 * Texcoord.xy;\n")
   +string("    vec2 mouse = pi * ((pos2d.xy + 0.001) / vec2(1.0,1.0) * vec2(-2.0, 1.0));\n")
   +string("    // camera\n")
   +string("    const float motion_speed = 1.0;\n")
   +string("    float motion = (0.3 * cos(motion_speed * time * 0.2) + 0.7);\n")
   +string("    mouse += mod(motion_speed * time * 0.1, 2.0 * pi);\n")
   +string("    vec3 origin = camera_radius * motion * normalize(vec3(cos(mouse.x) * sin(mouse.y), cos(mouse.y), sin(mouse.x) * sin(mouse.y)));\n")
   +string("    vec3 target = vec3(0.0);\n")
   +string("    // orthonormal basis\n")
   +string("    vec3 vz = normalize(target - origin);\n")
   +string("    vec3 vx = normalize(cross(vec3(0.0, 1.0, 0.0), vz));\n")
   +string("    vec3 vy = normalize(cross(vz, vx));\n")
   +string("    // ray \n")
   +string("    vec3 ray = normalize(vx*pixel.x + vy*pixel.y + vz*field_of_view);\n")
   +string("    vec4 trace = ray_trace(origin, ray);\n")
   +string("    // stars\n")
   +string("    outColor = vec4(haze(ray, star_field(ray, 18.0)), 1.0);\n")
   +string("    outColor += vec4(star_field(ray, 4.0), 1.0);\n")
   +string("    star_brightness = star_brightness*1.6; // lens flares\n")
   +string("    outColor += vec4( lens_flare(pixel, screen_space(ray, vx, vy, vz), star_brightness), 1.0);\n")
   +string("    // nebula\n")
   +string("    outColor = vec4(mix(outColor.xyz, trace.xyz, trace.w), 1.0);\n")
   +string("}\n")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void ToonTroidShader::Init() {
  OUTPUT("ToonTroidShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec2 scale;\n")
   +string("uniform float time;\n")
   +string("uniform float sway;         // = 2.12\n")
   +string("uniform vec3 L;             // = normalize(vec3(10.25,.33,-.7));\n")
   +string("uniform float backlight;    // .15\n")
   +string("uniform vec3 cam;           // = vec3(-2.0,0,0) \n")
   +string("uniform vec3 diffuseColor;  // 1.0, 0.9, 0.7\n")
   +string("uniform vec3 ambientColor;  // 0.1, 0.11, 0.13\n")
   +string("uniform vec3 tintColor;  // 1.0 1.0 1.0 \n")
   +string("uniform vec4 lightComponents; // 0.1, 0.2, 0.5, 0.2\n")
   +string("uniform float emmissive;    // 0.1\n")
   +string("uniform vec2 rotation;      // radians\n")
   +string("uniform float roughness;    // = 0.001\n")
   +string("uniform vec2 dimensions;    // = 0.54030230586, 0.8414709848, -0.8414709848, 0.54030230586\n")
   +string("uniform vec4 craterDims;    // .25, .05, 0.5, .15\n")
   +string("uniform vec4 craterParams;  // .15, .6, 5.0, 0.0*f\n")
   +string("uniform vec4 surfaceParams; // 0.005, 0.1, 2.0, 20.0\n")
   +string("uniform vec4 kaleidoscope;  // .9, .6, .2, .15   ... make z a huge number for odd effects\n")
   +string("uniform sampler2D noiseTex;\n")
   +string("const int NB_ITER=128;\n")
   +string("const float PI=3.1415926535897932384626433832795;\n")
   +string("const float TAO=6.28318531;\n")
   +string("const float MAX_DIST=4000.0;\n")
   +string("const float PRECISION=-0.0001;\n")
   +string("const float PLANET=200.0;\n")
   +string("const vec2 V01 = vec2(0,1);\n")
   +string("vec2 Ve = V01.yx*roughness;\n")
   +string("mat2 Rot1 = mat2(dimensions.x,dimensions.y,-dimensions.x,dimensions.y);\n")
   +string("float C1,S1, C2, S2, t; \n")
   +string("bool withPlanet = true;\n")
   +string("float Noise(in vec3 x) {\n")
   +string("    vec3 p = floor(x);\n")
   +string("    vec3 f = fract(x);\n")
   +string("	f = f*f*(3.0-2.0*f);\n")
   +string("	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n")
   +string("	vec2 rg = texture2D( noiseTex, (uv+ 0.5)/256.0, -100.0 ).yx;\n")
   +string("	return mix( rg.x, rg.y, f.z );\n")
   +string("}\n")
   +string("float Noise( in vec2 x ) {\n")
   +string("    vec2 p = floor(x);\n")
   +string("    vec2 f = fract(x);\n")
   +string("	vec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n")
   +string("	return texture2D( noiseTex, (uv+118.4)/256.0, -100.0 ).x;\n")
   +string("}\n")
   +string("float smin( float a, float b, float k ) {\n")
   +string("    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n")
   +string("    return mix(b, a, h ) - k*h*(1.0-h);\n")
   +string("}\n")
   +string("float Kaleido(inout vec2 v, in float nb){\n")
   +string("	float id=floor(.5+atan(v.x,-v.y)*nb/TAO);\n")
   +string("	float a = id*TAO/nb;\n")
   +string("	float ca = cos(a), sa = sin(a);\n")
   +string("	v*=mat2(ca,sa,-sa,ca);\n")
   +string("	return id;\n")
   +string("}\n")
   +string("vec2 Kaleido2(inout vec3 p, float nb1, float nb2, float d) {\n")
   +string("	float id1 = Kaleido(p.yx, nb1);\n")
   +string("	float id2 = Kaleido(p.xz, nb2*2.);\n")
   +string("	p.z+=d;	\n")
   +string("	return vec2(id1,id2);\n")
   +string("}\n")
   +string("vec2 minObj(vec2 o1, vec2 o2) {\n")
   +string("	return o1.x<o2.x?o1:o2;\n")
   +string("}\n")
   +string("vec2 sminObj(vec2 o1, vec2 o2, float k) {\n")
   +string("	float d = smin(o1.x, o2.x, k);\n")
   +string("	return vec2(d, o1.x<o2.x?o1.y:o2.y);\n")
   +string("}\n")
   +string("vec2 maxObj(vec2 o1, vec2 o2) {\n")
   +string("	return o1.x>o2.x?o1:o2;\n")
   +string("}\n")
   +string("float sdCapsule( vec3 p, vec3 a, vec3 b, float r1, float r2) {\n")
   +string("    vec3 pa = p - a, ba = b - a;\n")
   +string("    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n")
   +string("    return length( pa - ba*h ) - mix(r1,r2,h);\n")
   +string("}\n")
   +string("float DECrater(vec3 p) {\n")
   +string("	float d = MAX_DIST;\n")
   +string("	vec2 id = Kaleido2(p, kaleidoscope.x, kaleidoscope.y, kaleidoscope.z);\n")
   +string("	float noise = Noise(id*10.);\n")
   +string("	if (noise<craterParams.y && abs(id.y)>craterParams.w && abs(id.y)<craterParams.z) {  \n")
   +string("		d = sdCapsule(p, vec3(0,0,-craterParams.x), vec3(0,0,.1),.1+noise*.2,.1+noise*.5);\n")
   +string("		d = max(-(length(p-vec3(0,0,-craterDims.x))-(.1+noise*craterDims.z)),d);\n")
   +string("		d = max(-(length(p-vec3(0,0,-craterDims.y))-(.1+noise*craterDims.w)),d);\n")
   +string("		d*=.8;\n")
   +string("	}\n")
   +string("	return d;\n")
   +string("}\n")
   +string("bool intersectSphere(vec3 ro, vec3 rd, vec3 c, float r) {\n")
   +string("    ro -= c;\n")
   +string("	float b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n")
   +string("	return (d>0. && -sqrt(d)-b > 0.);\n")
   +string("}\n")
   +string("// vec4 : distance / id (object) / uv (texture) \n")
   +string("vec4 DE(vec3 p0) {\n")
   +string("	float scalePlanet = 10.0;\n")
   +string("	vec4 res = vec4(1000);	\n")
   +string("	vec3 p = p0;\n")
   +string("    float d,d1,dx;\n")
   +string("	p = p0;\n")
   +string("	p.x+=2.;\n")
   +string("	p*=scalePlanet;\n")
   +string("	p.yz *= Rot1;\n")
   +string("	p.xz *= mat2(C2,S2,-S2,C2);\n")
   +string("	d1 = DECrater(p);\n")
   +string("	d = smin(length(p)-2.,d1,kaleidoscope.w); //smin(d2, d1,.2),.15);\n")
   +string("\n")
   +string("	d += surfaceParams.y*Noise((p)*surfaceParams.z);\n")
   +string("	d += surfaceParams.x*Noise((p)*surfaceParams.w);\n")
   +string("	res = vec4(d/=scalePlanet,PLANET, length(p), p.z);\n")
   +string("	return res;\n")
   +string("}\n")
   +string("vec3 N(vec3 p) {\n")
   +string("    vec2 e = vec2(Ve.x, -Ve.x); \n")
   +string("    return normalize(e.xyy * DE(p + e.xyy).x + e.yyx * DE(p + e.yyx).x + e.yxy * DE(p + e.yxy).x + e.xxx * DE(p + e.xxx).x);;\n")
   +string("}\n")
   +string("float softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n")
   +string("	float res = 1.0, h, t = mint;\n")
   +string("    for( int i=0; i<20; i++ ) {\n")
   +string("		h = DE( ro + rd*t ).x;\n")
   +string("		res = min( res, k*h/t );\n")
   +string("                if( res<0.0001 ) break;\n")
   +string("		t += 0.02;\n")
   +string("    }\n")
   +string("    return clamp(res, 0., 1.);\n")
   +string("}\n")
   +string("float one_pi = 0.31830988618;\n")
   +string("float lightIntensity = 1.0;\n")
   +string("vec4 findColor(float obj, vec2 uv, vec3 n) {\n")
   +string("    if (obj == PLANET) {\n")
   +string("		return vec4(mix(vec3(.7,.7,.7),vec3(1,1,1), clamp(1.1-5.*(uv.x-1.8),0.1,.9)),1.0);\n")
   +string("	} else {\n")
   +string("		return vec4(0.0,0.0,0.0,0.0);\n")
   +string("	}\n")
   +string("}\n")
   +string("vec4 Render(vec3 p, vec3 rd, float t, float obj, vec2 uv) {\n")
   +string("	//return V01.xxy*(dot(N(p),L));	\n")
   +string("\n")
   +string("	vec3 nor = N(p);\n")
   +string("	vec4 foundColor = findColor(obj, uv, reflect(rd,nor));	\n")
   +string("    vec3 col = foundColor.xyz;\n")
   +string("	vec3 sunLight = normalize(L);\n")
   +string("	float	amb = clamp(.5+.5*nor.y, .0, 1.),\n")
   +string("            dif = clamp(dot( nor, sunLight ), 0., 1.),\n")
   +string("            bac = clamp(dot( nor, normalize(vec3(-sunLight.x,0.,-sunLight.z))), 0., 1.)*clamp( 1.0-p.y,0.0,1.0);\n")
   +string("	float sh = softshadow( p, sunLight, .02, 100., 7.); \n")
   +string("	if (obj != PLANET ) {\n")
   +string("        return vec4(0.0,0.0,0.0,0.0);\n")
   +string("	} else {\n")
   +string("	    dif *= sh; \n")
   +string("		vec3 brdf = lightComponents.w*(amb*ambientColor + bac*backlight) +	1.2*dif*diffuseColor;\n")
   +string("		float fre = pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n")
   +string("		col = col*(lightComponents.x+brdf + emmissive) + lightComponents.y*fre*(lightComponents.z+.5*col)*exp(-.01*t*t);\n")
   +string("		return vec4(sqrt(clamp(col,0.,1.)),foundColor.w);\n")
   +string("	}\n")
   +string("}\n")
   +string("mat3 lookat(vec3 ro, vec3 up){\n")
   +string("	vec3 fw=normalize(ro);\n")
   +string("	vec3 rt=normalize(cross(fw,up));\n")
   +string("	return mat3(rt, cross(rt,fw),fw);\n")
   +string("}\n")
   +string("vec3 RD(vec3 ro, vec3 cp, vec2 fCoord) {\n")
   +string("	return lookat(cp-ro, V01.yxx)*normalize(vec3((2.*fCoord), 12.0));\n")
   +string("}\n")
   +string("void main() {\n")
   +string("	t = 3.0*TAO+time*0.75;	\n")
   +string("	C1 = cos(rotation.y);\n")
   +string("	S1 = sin(rotation.y);\n")
   +string("	S2 = 2.0*S1*C1;\n")
   +string("	C2 = 1.0-2.0*S1*S1;	\n")
   +string("	t /= TAO;\n")
   +string("	vec3 cp = vec3(-2.0,0,0);\n")
   +string("	float rCam = 5.0;\n")
   +string("	vec3 rd, ro = rCam*vec3(-0.5+4.0*scale.y,\n")
   +string("						-abs(sin(t*sway+scale.x)),\n")
   +string("						-abs(cos(t*sway))\n")
   +string("					    );	\n")
   +string("	vec4 ctot = vec4(0);\n")
   +string("		vec2 fCoord = ( (Texcoord.xy * 2.0) - vec2(1.0) ) / vec2(3.0);\n")
   +string("		rd = RD(ro, cp, fCoord);	\n")
   +string("        withPlanet = intersectSphere(ro, rd, cam,0.21);        \n")
   +string("		// Ray marching\n")
   +string("		float t=0.0,d=1.0,od=1.0;\n")
   +string("		vec4 res=vec4(0.0);\n")
   +string("		for(int i=0;i<NB_ITER;i++){\n")
   +string("			if(d<PRECISION|| t>MAX_DIST)break;\n")
   +string("			t += res.x;\n")
   +string("			res=DE(ro+rd*t); // *0.95;\n")
   +string("		}	\n")
   +string("		// Render colors\n")
   +string("		if(t<MAX_DIST){// if we hit a surface color it\n")
   +string("			ctot += Render(ro + rd*t, rd,t, res.y, res.zw);\n")
   +string("		}	\n")
   +string("	outColor = ctot*vec4(tintColor,1.0);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void TexturedPlanetShader::Init() {
  OUTPUT("TexturedPlanetShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec2 pos2d;\n")
   +string("uniform vec3 LIGHT_COLOR;  // vec3(252.,212.,128.)/255.\n")
   +string("uniform vec3 LIGHT_AMB_COLOR;  // vec3(.3)\n")
   +string("uniform vec3 LIGHT_DIFF_COLOR; // vec3(1.)\n")
   +string("uniform vec3 LIGHT_SPEC_COLOR; // vec3(0.25)\n")
   +string("uniform vec3 LIGHT_DIR;  // normalize(vec3(45.,30.,45.))\n")
   +string("uniform float tilt;      //=0.75;\n")
   +string("uniform sampler2D noiseTex;\n")
   +string("uniform sampler2D surfaceTex;\n")
   +string("const int MAX_ITERATIONS =16;\n")
   +string("const float MAX_DISTANCE =20000.0;\n")
   +string("const float SHADOW_BIAS  =0.01;\n")
   +string("const float EPSILON = 0.001;\n")
   +string("const float PI = 3.14159265358979323846264338327950288419;\n")
   +string("vec2 rot2D(vec2 p, float angle) {\n")
   +string("	angle = radians(angle);\n")
   +string("    float s = sin(angle), c = cos(angle);\n")
   +string("    return mat2(c,s,-s,c)*p;\n")
   +string("}\n")
   +string("float noise( in vec3 x )\n")
   +string("{\n")
   +string("    vec3 p = floor(x);\n")
   +string("    vec3 f = fract(x);\n")
   +string("	f = f*f*(3.0-2.0*f);\n")
   +string("	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n")
   +string("	vec2 rg = texture2D( noiseTex, (uv+ 0.5)/256.0, -100.0 ).yx;\n")
   +string("	return -1.0+2.0*mix( rg.x, rg.y, f.z );\n")
   +string("}\n")
   +string("float dstScene(vec3 p) {\n")
   +string("    vec3  n = normalize(p);\n")
   +string("    vec2 uv = asin(n.xy)/PI+0.5;\n")
   +string("    float h = texture2D(surfaceTex,uv).x*0.1;\n")
   +string("	return length(p)-(6300.0+(1250.0*h));\n")
   +string("}\n")
   +string("float raymarch(vec3 ori, vec3 dir) {\n")
   +string("    float t = 0.;\n")
   +string("    for(int i = 0; i < MAX_ITERATIONS; i++) {\n")
   +string("    	float scn = dstScene(ori+dir*t);\n")
   +string("        if(scn < EPSILON*t || t > MAX_DISTANCE)\n")
   +string("            break;\n")
   +string("        t += scn * 0.75;\n")
   +string("    }\n")
   +string("    return t;\n")
   +string("}\n")
   +string("vec3 calcNormal(vec3 p, float t) {\n")
   +string("	vec2 e = vec2(EPSILON*t,0.0);\n")
   +string("    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),dstScene(p+e.yxy)-dstScene(p-e.yxy),dstScene(p+e.yyx)-dstScene(p-e.yyx));\n")
   +string("    return normalize(n);\n")
   +string("}\n")
   +string("float softshadow( vec3 ro, vec3 rd, float mint, float tmax, float k )\n")
   +string("{\n")
   +string("	float res = 1.0;\n")
   +string("    float t = mint;\n")
   +string("    for( int i=0; i<64; i++ )\n")
   +string("    {\n")
   +string("		float h = dstScene( ro + rd*t );\n")
   +string("        res = min( res, k*h/t );\n")
   +string("        t += clamp( h, 0.07, 0.5 );\n")
   +string("        if( h<0.001 || t>tmax ) break;\n")
   +string("    }\n")
   +string("    return clamp( res, 0.0, 1.0 );\n")
   +string("}\n")
   +string("vec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sh, vec3 ori) {\n")
   +string("	vec3 ds = vec3(0.0);\n")
   +string("    vec3 ss = vec3(0.0);\n")
   +string("    float d = max(dot(LIGHT_DIR,n),0.0);\n")
   +string("    float s = 0.0;\n")
   +string("    d *= softshadow(p,LIGHT_DIR,SHADOW_BIAS,MAX_DISTANCE,64.0);\n")
   +string("    if(d > 0.0 && sh > 0.0)\n")
   +string("        s = pow(max(dot(LIGHT_DIR,r),0.0),sh);\n")
   +string("    ds += LIGHT_COLOR * d;\n")
   +string("    ss += LIGHT_COLOR * s;\n")
   +string("    vec3 plv = ori-p;\n")
   +string("    vec3 pld = normalize(plv);\n")
   +string("    d = max(dot(pld,n),0.0);\n")
   +string("    s = 0.;\n")
   +string("    d *= softshadow(p,pld,SHADOW_BIAS,length(plv),64.0);\n")
   +string("    if(d > 0.0 && sh > 0.0)\n")
   +string("        s = pow(max(dot(pld,r),0.0),sh);\n")
   +string("    float a = 1.0-clamp(length(plv)/3500.0,0.0,1.0);\n")
   +string("    ds += vec3(d*a);\n")
   +string("    ss += vec3(s*a);\n")
   +string("    return (col*(LIGHT_AMB_COLOR+ds*LIGHT_DIFF_COLOR))+ss*LIGHT_SPEC_COLOR;\n")
   +string("}\n")
   +string("vec4 shade(vec3 ori, vec3 dir) {\n")
   +string("    float  t = raymarch(ori,dir);\n")
   +string("    vec4 col = vec4(0.0);    \n")
   +string("    if(t < MAX_DISTANCE) {\n")
   +string("    	vec3 p = ori+dir*t;\n")
   +string("        vec3 n = calcNormal(p,t);\n")
   +string("        vec3 r = normalize(reflect(dir, n));        \n")
   +string("        vec2 uv = asin(n.xy)/PI+0.5;        \n")
   +string("        col = vec4(texture2D(noiseTex,uv*2.0).xyz,1.0);\n")
   +string("        vec3 lighting=calcLighting(col.xyz, p, n, r, 30.0, ori);\n")
   +string("        col = vec4(lighting,1.0);\n")
   +string("    float f = pow(max(dot(LIGHT_DIR,dir),0.0),60.0);\n")
   +string("  	if(raymarch(ori,LIGHT_DIR) >= MAX_DISTANCE)\n")
   +string("         col += vec4(LIGHT_COLOR * f,1.0);\n")
   +string("    } else {\n")
   +string("    	col = vec4(0.0,0.0,0.0,0.0); //col = getSky(dir);\n")
   +string("    }    \n")
   +string("    return col;    \n")
   +string("}\n")
   +string("vec3 getCameraOrigin(float t) {\n")
   +string("	float gt = 1.0; //mod(t, 15.0);\n")
   +string("    float  r = 1.0-(smoothstep(3.0,6.0,gt)*(1.0-smoothstep(12.0,15.0,gt)));\n")
   +string("    float  a = radians(35.0*(2.0+t*0.1));\n")
   +string("    return vec3(cos(a),tilt,sin(a))*mix(1050.0,15000.0,r);\n")
   +string("}\n")
   +string("void main()\n")
   +string("{\n")
   +string("	vec2 uv =  (Texcoord.xy * 2.0 - vec2(1.0) ) / vec2(2.0);\n")
   +string("    vec3 ori = getCameraOrigin(pos2d.x);\n")
   +string("    vec3 dir = vec3(uv,1.0);\n")
   +string("    vec3 f = normalize(-ori);\n")
   +string("    vec3 u = normalize(cross(f,vec3(0.0,1.0,0.0)));\n")
   +string("    vec3 v = normalize(cross(u,f));\n")
   +string("    dir = normalize(mat3(u,v,f)*dir);\n")
   +string("	outColor = shade(ori,dir);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void EarthlikeShader::Init() {
  OUTPUT("EarthlikeShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec2 pos2d;\n")
   +string("uniform float time;\n")
   +string("uniform float timescale;\n")
   +string("uniform vec2 noiseOffset; //= vec2(0.0, 0.0);\n")
   +string("uniform vec2 noiseScale;  //= vec2(16.0, 16.0);\n")
   +string("uniform vec2 noiseScale2; //= vec2(200.0, 200.0);\n")
   +string("uniform vec2 noiseScale3; //= vec2(50.0, 50.0);\n")
   +string("uniform vec2 cloudNoise;  //= vec2(10.0, 30.0);\n")
   +string("uniform vec3 oceanColor;     //= vec3(13.0 / 255.0, 55.0 / 255.0, 79.0 / 255.0);\n")
   +string("uniform vec3 iceColor;       //= vec3(250.0 / 255.0, 250.0 / 255.0, 250.0 / 255.0);\n")
   +string("uniform vec3 coldColor;      //= vec3(53.0 / 255.0, 102.0 / 255.0, 100.0 / 255.0);\n")
   +string("uniform vec3 temperateColor; //= vec3(79.0 / 255.0, 109.0 / 255.0, 68.0 / 255.0);\n")
   +string("uniform vec3 warmColor;      //= vec3(119.0 / 255.0, 141.0 / 255.0, 82.0 / 255.0);\n")
   +string("uniform vec3 hotColor;       //= vec3(223.0 / 255.0, 193.0 / 255.0, 148.0 / 255.0);\n")
   +string("uniform float cloudiness;  //= 0.5\n")
   +string("float t10 = time * timescale;\n")
   +string("float left = 0.0;\n")
   +string("float top = 0.0;\n")
   +string("vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n")
   +string("vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n")
   +string("vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n")
   +string("vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n")
   +string("float spow(float x, float y) { float s = sign(x); return s * pow(s * x, y); }\n")
   +string("float pnoise(vec2 P, vec2 rep)\n")
   +string("{\n")
   +string("  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n")
   +string("  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n")
   +string("  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n")
   +string("  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n")
   +string("  vec4 ix = Pi.xzxz;\n")
   +string("  vec4 iy = Pi.yyww;\n")
   +string("  vec4 fx = Pf.xzxz;\n")
   +string("  vec4 fy = Pf.yyww;\n")
   +string("  vec4 i = permute(permute(ix) + iy);\n")
   +string("  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n")
   +string("  vec4 gy = abs(gx) - 0.5 ;\n")
   +string("  vec4 tx = floor(gx + 0.5);\n")
   +string("  gx = gx - tx;\n")
   +string("  vec2 g00 = vec2(gx.x,gy.x);\n")
   +string("  vec2 g10 = vec2(gx.y,gy.y);\n")
   +string("  vec2 g01 = vec2(gx.z,gy.z);\n")
   +string("  vec2 g11 = vec2(gx.w,gy.w);\n")
   +string("  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n")
   +string("  g00 *= norm.x;  \n")
   +string("  g01 *= norm.y;  \n")
   +string("  g10 *= norm.z;  \n")
   +string("  g11 *= norm.w;\n")
   +string("  float n00 = dot(g00, vec2(fx.x, fy.x));\n")
   +string("  float n10 = dot(g10, vec2(fx.y, fy.y));\n")
   +string("  float n01 = dot(g01, vec2(fx.z, fy.z));\n")
   +string("  float n11 = dot(g11, vec2(fx.w, fy.w));\n")
   +string("  vec2 fade_xy = fade(Pf.xy);\n")
   +string("  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n")
   +string("  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n")
   +string("  return 2.3 * n_xy;\n")
   +string("}\n")
   +string("vec4 planet(vec2 pix, float rotspeed, float rot, float light, float zLight) {\n")
   +string(" vec2 p = -1.0 + 2.0 * pix;\n")
   +string(" p = mat2(cos(rot), sin(rot), -sin(rot), cos(rot)) * p;	\n")
   +string(" vec3 ro = vec3( 0.0, 0.0, 2.25 );\n")
   +string(" vec3 rd = normalize( vec3( p, -2.0 ) );\n")
   +string(" vec3 col = vec3(0.0);\n")
   +string(" // intersect sphere\n")
   +string(" float b = dot(ro,rd);\n")
   +string(" float c = dot(ro,ro) - 1.0;\n")
   +string(" float h = b*b - c;\n")
   +string("	float t = -b - sqrt(h);\n")
   +string("	vec3 pos = ro + t*rd;\n")
   +string("	vec3 nor = pos;\n")
   +string("	// texture mapping\n")
   +string("	vec2 uv = vec2( (atan(nor.x,nor.z)/6.2831 + rotspeed*t10) , (acos(nor.y)/3.1416) );\n")
   +string("	uv.y = 0.5 + spow(uv.y - 0.5, 1.2);\n")
   +string("	uv += noiseOffset;	\n")
   +string("	float n2 = pnoise(uv * noiseScale2, noiseScale2) * 0.05;\n")
   +string("	float n = pnoise(uv * noiseScale, noiseScale) + n2;	\n")
   +string("	float temp = cos(nor.y * 4.0) + pnoise(uv * noiseScale3, noiseScale3) * 0.8 + n * 0.5;	\n")
   +string("	float oceanity = min(1.0, 1.0 - smoothstep(0.19, 0.2, n) + 1.0 - smoothstep(0.05, 0.08, mod(temp - uv.x * 35.0 + 0.3, 1.0) + n * n * 0.35));\n")
   +string("	float iceity = max(0.0, 1.0 - oceanity - smoothstep(-0.8, -0.6, temp));\n")
   +string("	float coldity = max(0.0, 1.0 - iceity - oceanity - smoothstep(-0.4, 0.0, temp));\n")
   +string("	float temperateity = max(0.0, 1.0 - iceity - coldity - oceanity - smoothstep(0.3, 0.8, temp));\n")
   +string("	float warmity = max(0.0, 1.0 - iceity - coldity - temperateity - oceanity - smoothstep(1.05, 1.3, temp));\n")
   +string("	float hottity = max(0.0, 1.0 - oceanity - iceity - coldity - temperateity - warmity);	\n")
   +string("	col = oceanColor * oceanity + iceColor * iceity + coldColor * coldity + temperateColor * temperateity + warmColor * warmity + hotColor * hottity;\n")
   +string("	col *= (0.7 + abs(temp + n * 0.2) * 0.3);\n")
   +string("	col *= 0.92 + step(0.1, mod(n2, 0.4)) * 0.08;\n")
   +string("	col *= 1.0 + step(0.39, mod(n + uv.x, 0.4)) * 0.1;\n")
   +string("	float cloudN = max(0.0, pnoise((uv + vec2(rotspeed * t10, 0)) * cloudNoise, cloudNoise) + cloudiness + n2);\n")
   +string("	col *= 0.7;\n")
   +string("	col += vec3(cloudN, cloudN, cloudN) * 0.5;\n")
   +string(" float lighting = max(sin(light) * nor.y * 2.0 + cos(light) * nor.x * 2.0 + nor.z * zLight,0.0);\n")
   +string("	col *= 0.2 + lighting * 0.7;\n")
   +string(" float den=step(0.0, h);")
   +string(" return vec4(mix(vec3(0.0), col, den), den);\n")
   +string("}\n")
   +string("void main() {\n")
   +string("	vec2 coord = Texcoord;\n")
   +string("	coord.x += left + pos2d.x;\n")
   +string("	coord.y += top + pos2d.y;\n")
   +string("	vec4 col = planet(coord, 0.05, float(int(t10 * 0.08)), t10 * 0.1, sin(t10 * 0.05) * 2.0);\n")
   +string("	outColor=col; //vec4(col.xyz,min(1.0,0.95+col.x+col.y+col.z));\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void AccretionShader::Init() {
  OUTPUT("AccretionShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec2 pos2d;       \n")
   +string("uniform vec3 scale;       //=vec2(1.1,1.8,0.9)\n")
   +string("uniform sampler2D tex1;\n")
   +string("uniform sampler2D tex2;\n")
   +string("uniform sampler2D tex3;\n")
   +string("uniform float time;\n")
   +string("vec2 uniformCoord(vec2 uv) { return vec2(uv); }\n")
   +string("vec2 rotate(vec2 uv, float angle)\n")
   +string("{\n")
   +string("    float s = sin(angle);\n")
   +string("    float c = cos(angle);\n")
   +string("    return uv * mat2(c, s, -s, c);\n")
   +string("}\n")
   +string("vec2 pp(vec2 uv)\n")
   +string("{\n")
   +string("    float y = uv.y * 0.5 + 0.5;\n")
   +string("    float ny = scale.y * y * scale.z;\n")
   +string("    return vec2(uv.x / scale.x * (1.0 - ny / 3.0), ny * 2.0 - 1.5);\n")
   +string("}\n")
   +string("float spiral(vec2 uv)\n")
   +string("{\n")
   +string("    float dist = 1.0 - length(uv);\n")
   +string("    float d = dist * 0.6 * texture2D(tex1, rotate(uv * 2.5, time * 0.1 + dist * 3.0)).x\n")
   +string("            + dist * 0.5 * texture2D(tex1, rotate(uv * 2.5, time * 0.125 + dist * 3.0)).x;\n")
   +string("    for(int i=0; i < 10; ++i)\n")
   +string("    {\n")
   +string("        vec2 coord = uv * (1.0 - fract(time * -0.02 + float(i) * 0.089));\n")
   +string("        coord = rotate(coord, time * 0.01 + dist * float(i) * 0.2);\n")
   +string("        vec2 tx = texture2D(tex1, coord).xy;\n")
   +string("        d += tx.x / 30.0;\n")
   +string("        d -= tx.y / 70.0;\n")
   +string("    }\n")
   +string("    return d;\n")
   +string("}\n")
   +string("vec3 star(vec2 uv)\n")
   +string("{\n")
   +string("    const float aspect = 5.5;\n")
   +string("    const float radius = 1.0/aspect;\n")
   +string("    vec3 c = vec3(0.0);\n")
   +string("    float dist = distance(uv, vec2(0,0));\n")
   +string("    uv = uv * aspect;\n")
   +string("    float r = dot(uv,uv);\n")
   +string("    float f = (1.0-sqrt(abs(1.0-r)))/(r);\n")
   +string("    if( dist < radius ){\n")
   +string("  	   vec2 newUv      = vec2(uv.x * f, (uv.y - 0.8) * f);		\n")
   +string("	   float wobble    = texture2D( tex2, newUv ).r * 0.3;\n")
   +string("	   float uOff      = ( wobble - time * 0.2);\n")
   +string("	   vec2 starUV	   = newUv + vec2( uOff, 0.0 );\n")
   +string("	   vec3 starSphere = texture2D( tex2, starUV ).rgb;\n")
   +string("       c = starSphere;\n")
   +string("       c = vec3(c.r + 1., c.g + 1., c.b + 1.1);\n")
   +string("       c *= (1.0 - dist * aspect);\n")
   +string("    }\n")
   +string("    c = c * (uv.y * 2.0 + 0.3);\n")
   +string("    return clamp(c, -0.03, 1.0);\n")
   +string("}\n")
   +string("vec3 gas(vec2 uv, float distort)\n")
   +string("{\n")
   +string("    const vec3 grading1	= vec3( 0.15, 0.7, 1.8 );\n")
   +string("    const vec3 grading2	= vec3( 1.0, 0.55, 0.0 );\n")
   +string("    const vec3 grading3	= vec3( 2.5, 1.0, 0.5 );\n")
   +string("    float dist = (1.0 - length(uv * vec2(0.6, 1.4))) * 0.04;\n")
   +string("    vec2 wobble = texture2D(tex2, rotate(uv, time * 0.1)).rg * dist;\n")
   +string("    vec3 c = vec3(spiral(pp(uv * 0.9 + wobble + distort * 0.5)));\n")
   +string("    vec3 cColor = vec3(c + ((c - 0.5) * grading1) + (c * grading2) + ((atan(c) * 0.3 + 1.1) * grading3 *0.1));\n")
   +string("    return cColor;\n")
   +string("}\n")
   +string("vec3 parts(vec2 uv)\n")
   +string("{\n")
   +string("    vec3 fi = texture2D(tex2, rotate(pp(uv), time * 0.06)).rgb;\n")
   +string("    vec2 uv1 = pp((uv + fi.rg * 4.1) * 0.8) * 0.5;\n")
   +string("    vec2 uv2 = pp((uv ) * 1.8) * 0.9;\n")
   +string("	float dist = 1.0 - length(uv * vec2(0.1, 0.2));\n")
   +string("    float d = dist * 0.63 * texture2D(tex3, rotate(uv1.yy, time * 0.01 + dist * 1.0)).x\n")
   +string("            + dist * 0.5 * texture2D(tex3, rotate(uv1, time * 0.12 + dist * 1.2)).x\n")
   +string("            + dist * 0.33 * texture2D(tex3, rotate(uv2.xx, time * 0.014 + dist * 1.4)).x\n")
   +string("            + dist * 0.7 * texture2D(tex3, rotate(uv2, time * 0.16 + dist * 1.6)).x;    \n")
   +string("    vec3 c = vec3(pow(d, 8.0) *  0.2) * fi;\n")
   +string("    return c;\n")
   +string("}\n")
   +string("void main()\n")
   +string("{\n")
   +string("	vec2 uv =  (Texcoord.xy * 2.0 - vec2(1.0) ) / vec2(2.0)\n") //uniformCoord(-pos2d.xy+Texcoord*1.5);\n")
   +string("    vec3 c1 = parts(uv);\n")
   +string("    vec3 c2 = gas(uv, c1.r);\n")
   +string("    vec3 c3 = star(uv);\n")
   +string("    outColor = vec4((c1 + c2 + c3),(c1+c2+c3)/3.0);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void BlackHoleShader::Init() {
  OUTPUT("BlackHoleShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec3 color1; //= vec3(0.5,0.35,0.1)\n")
   +string("uniform vec3 color2; //= vec3(1.0,0.8,0.6)\n")
   +string("uniform vec3 color3; //= vec3(1.0,0.9,0.7)\n")
   +string("uniform vec2 orientation;\n")
   +string("uniform vec2 blackholeSize; // vec2(0.3,5.0)\n")
   +string("uniform vec3 attenuate;  // = vec2(0.1,0.75,0.1);\n")
   +string("uniform float time;\n")
   +string("uniform sampler2D tex2;\n")
   +string("const float pi = 3.141592659;\n")
   +string("float sdSphere( vec3 p, float s ) { return length(p)-s; }\n")
   +string("float sdCappedCylinder( vec3 p, vec2 h ) { \n")
   +string(" vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n")
   +string(" return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n")
   +string("}\n")
   +string("float sdTorus( vec3 p, vec2 t )\n")
   +string("{\n")
   +string(" vec2 q = vec2(length(p.xz)-t.x,p.y);\n")
   +string(" return length(q)-t.y;\n")
   +string("}\n")
   +string("void main()\n")
   +string("{\n")
   +string("	vec2 pp =  (Texcoord.xy * 2.0 - vec2(1.0) ) / vec2(2.0);\n")
   +string("	pp = -1.0 + 2.0*pp;\n")
   +string("	vec3 lookAt = vec3(0.0, -0.1, 0.0);\n")
   +string("    float eyer = 2.0;\n")
   +string("    float eyea = (orientation.x) * pi * 2.0;\n")
   +string("    float eyea2 = ((orientation.y)-0.24) * pi * 2.0;\n")
   +string("	vec3 ro = vec3( eyer * cos(eyea) * sin(eyea2), eyer * cos(eyea2), eyer * sin(eyea) * sin(eyea2)); //camera position\n")
   +string("	vec3 front = normalize(lookAt - ro);\n")
   +string("	vec3 left = normalize(cross(normalize(vec3(0.0,1.0,-0.1)), front));\n")
   +string("	vec3 up = normalize(cross(front, left));\n")
   +string("	vec3 rd = normalize(front*1.5 + left*pp.x + up*pp.y); // rect vector\n")
   +string("    vec3 bh = vec3(0.0,0.0,0.0);\n")
   +string("    float bhr = blackholeSize.x;\n")
   +string("    float bhmass = blackholeSize.y;\n")
   +string("   	bhmass *= 0.001; // premul G\n")
   +string("    vec3 p = ro;\n")
   +string("    vec3 pv = rd;\n")
   +string("    float dt = 0.02;\n")
   +string("    vec3 col = vec3(0.0);\n")
   +string("    float noncaptured = 1.0;\n")
   +string("    for(float t=0.0;t<1.0;t+=0.005)\n")
   +string("    {\n")
   +string("        p += pv * dt * noncaptured;        \n")
   +string("        vec3 bhv = bh - p;\n")
   +string("        float r = dot(bhv,bhv);\n")
   +string("        pv += normalize(bhv) * ((bhmass) / r);\n")
   +string("        noncaptured = smoothstep(0.0,0.01,sdSphere(p-bh,bhr));\n")
   +string("        float dr = length(bhv.xz);\n")
   +string("        float da = atan(bhv.x,bhv.z);\n")
   +string("        vec2 ra = vec2(dr,da * (0.01 + (dr - bhr)*0.002) + 2.0 * pi + time*0.02 );\n")
   +string("        ra *= vec2(10.0,20.0);\n")
   +string("        vec3 dcol = mix(color2,color1,pow(length(bhv)-bhr,2.0)) * max(0.0,texture2D(tex2,ra*vec2(0.1,0.5)).r+0.05) * (4.0 / ((0.001+(length(bhv) - bhr)*50.0) ));\n")
   +string("        col += max(vec3(0.0),dcol * step(0.0,-sdTorus( (p * vec3(1.0,50.0,1.0)) - bh, vec2(0.8,0.99))) * noncaptured);\n")
   +string("        // glow\n")
   +string("        col += color3 * attenuate.z * (1.0/vec3(dot(bhv,bhv))) * 0.003 * noncaptured;\n")
   +string("    }\n")
   +string("	float atten = attenuate.x+distance(Texcoord.xy,vec2(0.5,0.5)) * attenuate.y;\n")
   +string("	col = col*atten;\n")
   +string(" outColor = vec4(col,(col.x+col.y+col.z)/3.0);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void RingedJovianShader::Init() {
  OUTPUT("RingedJovianShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec3 ringColor;     //= vec3(0.95,0.8,0.7)\n")
   +string("uniform vec3 planetColor;   //= vec3(0.9,0.75,0.6)\n")
   +string("uniform vec4 surfaceParams; //= vec4(1.2,2.0,0.05,0.6)\n")
   +string("uniform vec3 ringParams;    //= vec3(8.1,126.0,0.6)\n")
   +string("uniform vec3 sunpos;        //= vec3(50,10,20);\n")
   +string("uniform float time;\n")
   +string("const int steps = 25;\n")
   +string("vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n")
   +string("vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n")
   +string("vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n")
   +string("vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n")
   +string("float snoise(vec3 v) {\n")
   +string("  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n")
   +string("  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n")
   +string("  vec3 i  = floor(v + dot(v, C.yyy) );\n")
   +string("  vec3 x0 =   v - i + dot(i, C.xxx) ;\n")
   +string("  vec3 g = step(x0.yzx, x0.xyz);\n")
   +string("  vec3 l = 1.0 - g;\n")
   +string("  vec3 i1 = min( g.xyz, l.zxy );\n")
   +string("  vec3 i2 = max( g.xyz, l.zxy );\n")
   +string("  vec3 x1 = x0 - i1 + C.xxx;\n")
   +string("  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n")
   +string("  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n")
   +string("  i = mod289(i);\n")
   +string("  vec4 p = permute( permute( permute(\n")
   +string("             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n")
   +string("           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n")
   +string("           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n")
   +string("  float n_ = 0.142857142857; // 1.0/7.0\n")
   +string("  vec3  ns = n_ * D.wyz - D.xzx;\n")
   +string("  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n")
   +string("  vec4 x_ = floor(j * ns.z);\n")
   +string("  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n")
   +string("  vec4 x = x_ *ns.x + ns.yyyy;\n")
   +string("  vec4 y = y_ *ns.x + ns.yyyy;\n")
   +string("  vec4 h = 1.0 - abs(x) - abs(y);\n")
   +string("  vec4 b0 = vec4( x.xy, y.xy );\n")
   +string("  vec4 b1 = vec4( x.zw, y.zw );\n")
   +string("  vec4 s0 = floor(b0)*2.0 + 1.0;\n")
   +string("  vec4 s1 = floor(b1)*2.0 + 1.0;\n")
   +string("  vec4 sh = -step(h, vec4(0.0));\n")
   +string("  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n")
   +string("  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n")
   +string("  vec3 p0 = vec3(a0.xy,h.x);\n")
   +string("  vec3 p1 = vec3(a0.zw,h.y);\n")
   +string("  vec3 p2 = vec3(a1.xy,h.z);\n")
   +string("  vec3 p3 = vec3(a1.zw,h.w);\n")
   +string("  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n")
   +string("  p0 *= norm.x;\n")
   +string("  p1 *= norm.y;\n")
   +string("  p2 *= norm.z;\n")
   +string("  p3 *= norm.w;\n")
   +string("  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n")
   +string("  m = m * m;\n")
   +string("  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n")
   +string("                                dot(p2,x2), dot(p3,x3) ) );\n")
   +string("}\n")
   +string("float torus (vec3 p, vec2 t) {\n")
   +string("  vec2 q = vec2(length(p.xz)-t.x,p.y);\n")
   +string("  return length(q)-t.y;\n")
   +string("}\n")
   +string("float sphere(vec3 p, float r) {\n")
   +string("  return length(p)-r;\n")
   +string("}\n")
   +string("mat4 scale (float x, float y, float z) {\n")
   +string("  return mat4(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);\n")
   +string("}\n")
   +string("mat4 invert(mat4 m) {\n")
   +string("  float\n")
   +string("      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n")
   +string("      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n")
   +string("      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n")
   +string("      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n")
   +string("      b00 = a00 * a11 - a01 * a10,\n")
   +string("      b01 = a00 * a12 - a02 * a10,\n")
   +string("      b02 = a00 * a13 - a03 * a10,\n")
   +string("      b03 = a01 * a12 - a02 * a11,\n")
   +string("      b04 = a01 * a13 - a03 * a11,\n")
   +string("      b05 = a02 * a13 - a03 * a12,\n")
   +string("      b06 = a20 * a31 - a21 * a30,\n")
   +string("      b07 = a20 * a32 - a22 * a30,\n")
   +string("      b08 = a20 * a33 - a23 * a30,\n")
   +string("      b09 = a21 * a32 - a22 * a31,\n")
   +string("      b10 = a21 * a33 - a23 * a31,\n")
   +string("      b11 = a22 * a33 - a23 * a32,\n")
   +string("      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n")
   +string("  return mat4(\n")
   +string("      a11 * b11 - a12 * b10 + a13 * b09,\n")
   +string("      a02 * b10 - a01 * b11 - a03 * b09,\n")
   +string("      a31 * b05 - a32 * b04 + a33 * b03,\n")
   +string("      a22 * b04 - a21 * b05 - a23 * b03,\n")
   +string("      a12 * b08 - a10 * b11 - a13 * b07,\n")
   +string("      a00 * b11 - a02 * b08 + a03 * b07,\n")
   +string("      a32 * b02 - a30 * b05 - a33 * b01,\n")
   +string("      a20 * b05 - a22 * b02 + a23 * b01,\n")
   +string("      a10 * b10 - a11 * b08 + a13 * b06,\n")
   +string("      a01 * b08 - a00 * b10 - a03 * b06,\n")
   +string("      a30 * b04 - a31 * b02 + a33 * b00,\n")
   +string("      a21 * b02 - a20 * b04 - a23 * b00,\n")
   +string("      a11 * b07 - a10 * b09 - a12 * b06,\n")
   +string("      a00 * b09 - a01 * b07 + a02 * b06,\n")
   +string("      a31 * b01 - a30 * b03 - a32 * b00,\n")
   +string("      a20 * b03 - a21 * b01 + a22 * b00) / det;\n")
   +string("}\n")
   +string("vec2 model(vec3 p) {\n")
   +string("  mat4 m = invert(scale(1.8,0.3,1.8));\n")
   +string("  float ring = torus(vec3(m*vec4(p,1)),vec2(4.5,0.5))\n")
   +string("    + snoise(p*8.0)*0.05;\n")
   +string("  float planet = sphere(p,4.0);\n")
   +string("  float sun = sphere(p-sunpos,2.0);\n")
   +string("  return vec2(min(ring,planet));//min(planet,sun)));\n")
   +string("}\n")
   +string("vec3 calcNormal(vec3 pos) {\n")
   +string("  const float eps = 0.002;\n")
   +string("  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n")
   +string("  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n")
   +string("  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n")
   +string("  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n")
   +string("  return normalize(v1*model(pos + v1*eps).x\n")
   +string("    + v2*model(pos + v2*eps).x\n")
   +string("    + v3*model(pos + v3*eps).x\n")
   +string("    + v4*model(pos + v4*eps).x);\n")
   +string("}\n")
   +string("vec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n")
   +string("  float latest = precis * 2.0;\n")
   +string("  float dist   = +0.0;\n")
   +string("  float type   = -1.0;\n")
   +string("  vec2  res    = vec2(-1.0, -1.0);\n")
   +string("  for (int i = 0; i < steps; i++) {\n")
   +string("    if (latest < precis || dist > maxd) break;\n")
   +string("    vec2 result = model(rayOrigin + rayDir * dist);\n")
   +string("    latest = result.x;\n")
   +string("    type = result.y;\n")
   +string("    dist += latest;\n")
   +string("  }\n")
   +string("  if (dist < maxd) res = vec2(dist, type);\n")
   +string("  return res;\n")
   +string("}\n")
   +string("vec2 raytrace(vec3 rayOrigin, vec3 rayDir) {\n")
   +string("  return calcRayIntersection(rayOrigin, rayDir, 50.0, 0.001);\n")
   +string("}\n")
   +string("vec2 square(vec2 screenSize) {\n")
   +string("  vec2 pos = 2.0 * (Texcoord.xy / screenSize.xy) - 1.0;\n")
   +string("  pos.x *= screenSize.x / screenSize.y;\n")
   +string("  return pos;\n")
   +string("}\n")
   +string("vec3 camera(mat3 camMat, vec2 screenPos, float lensLength) {\n")
   +string("  return normalize(camMat * vec3(screenPos, lensLength));\n")
   +string("}\n")
   +string("mat3 lookAt(vec3 origin, vec3 target, float roll) {\n")
   +string("  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n")
   +string("  vec3 ww = normalize(target - origin);\n")
   +string("  vec3 uu = normalize(cross(ww, rr));\n")
   +string("  vec3 vv = normalize(cross(uu, ww));\n")
   +string("  return mat3(uu, vv, ww);\n")
   +string("}\n")
   +string("vec3 camera(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n")
   +string("  mat3 camMat = lookAt(origin, target, 0.0);\n")
   +string("  return camera(camMat, screenPos, lensLength);\n")
   +string("}\n")
   +string("vec3 lighting (vec3 pos, vec3 nor, vec3 rd, float dis, vec3 mal) {\n")
   +string("  vec3 lin = vec3(0.0);\n")
   +string("  vec3  lig = normalize(vec3(1.0,0.7,0.9));\n")
   +string("  float dif = max(dot(nor,lig),0.0);\n")
   +string("  lin += dif*vec3(2);\n")
   +string("  lin += vec3(0.05);\n")
   +string("  return mal*lin;\n")
   +string("}\n")
   +string("void main() {\n")
   +string("  float t = time;\n")
   +string("  vec2 uv =  (Texcoord.xy * 2.0 - vec2(1.0) ) / vec2(2.0);\n")
   +string("  float cameraAngle = 0.01 * time;\n")
   +string("  vec3 rayOrigin = vec3(24.0 * sin(cameraAngle), 2.2, 24.0 * cos(cameraAngle));\n")
   +string("  vec3 rayTarget = vec3(0, 0, 0);\n")
   +string("  vec2 screenPos = square(Texcoord.xy);\n")
   +string("  float lensLength = 2.0;\n")
   +string("  vec3 rayDirection = camera(rayOrigin, rayTarget, screenPos, lensLength);\n")
   +string("  vec2 collision = raytrace(rayOrigin, rayDirection);\n")
   +string("  if (collision.x > -0.5) {\n")
   +string("    vec3 pos = rayOrigin + rayDirection * collision.x;\n")
   +string("    if (length(pos) <= 6.0) { // planet\n")
   +string("      vec3 nor = calcNormal(pos);\n")
   +string("      vec3 mat = (vec3(planetColor.x,planetColor.y,planetColor.z+sin(pos.y*2.0+3.0)*0.05))*vec3(\n")
   +string("        sin(pos.y*surfaceParams.y*sin(pos.y*2.5)+sin(pos.y*2.0)+snoise(pos*3.0)*0.4)*surfaceParams.z+surfaceParams.w\n")
   +string("      );\n")
   +string("      vec3 col = lighting(pos, nor, rayDirection, collision.x, mat);\n")
   +string("      col = pow(clamp(col,0.0,1.0), vec3(surfaceParams.x));\n")
   +string("     outColor = vec4(col, 1.0);\n")
   +string("    } else { // ring\n")
   +string("      float edge = length(pos)+snoise(pos*8.0)*0.03;\n")
   +string("      vec3 col = ringColor*vec3(\n")
   +string("        sin(1.5+sqrt(length(pos)*4.0)*ringParams.y+sqrt(sin(length(pos)*ringParams.z))\n")
   +string("          +snoise(pos*12.0)*0.3)*0.2+ringParams.x)\n")
   +string("        * 1.0 //(abs(edge-8.6)<0.5?1.5:1.0)\n")
   +string("      ;\n")
   +string("      if (length(pos)>=10.0) col = vec3(0,0,0);\n")
   +string("      else if (abs(pos.y)>0.35) col = vec3(0,0,0);\n")
   +string("      else { // shadow\n")
   +string("        vec3 p = normalize(-sunpos)*7.5;\n")
   +string("        col *= min(1.0,(length(pos-p)-4.0)/4.0);\n")
   +string("      }\n")
   +string("     outColor = vec4(col,1.0);\n")
   +string("    }\n")
   +string("  } else {\n")
   +string("   outColor = vec4(0.0,0.0,0.0,0.0);\n")
   +string("  }\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void ElectroPlanetShader::Init() {
  OUTPUT("ElectroPlanetShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec3 oColor;			   // = vec3( 0.2, 0.25, 0.3 );\n")
   +string("uniform vec3 oRColor;		   // = vec3( 0.6, 0.75, 0.6 );\n")
   +string("uniform float glowAmount;   // = 2.20;\n")
   +string("uniform vec2 pos2d;\n")
   +string("uniform float time;\n")
   +string("uniform sampler2D surfaceTex;\n")
   +string("uniform sampler2D sampleTex;\n")
   +string("float t10 = time * 0.1;\n")
   +string("float freqs1,freqs2;\n")
   +string("float snoise(vec3 uv, float res) {\n")
   +string("	const vec3 s = vec3(1e0, 1e2, 1e4);	\n")
   +string("	uv *= res;	\n")
   +string("	vec3 uv0 = floor(mod(uv, res))*s;\n")
   +string("	vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;	\n")
   +string("	vec3 f = fract(uv);\n")
   +string("	f = f*f*(3.0-2.0*f);	\n")
   +string("	vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n")
   +string("		      	  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);	\n")
   +string("	vec4 r = fract(sin(v*1e-3)*1e5);\n")
   +string("	float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);	\n")
   +string("	r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n")
   +string("	float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);	\n")
   +string("	return mix(r0, r1, f.z)*2.0-1.0;\n")
   +string("}\n")
   +string("void main() {\n")
   +string("//	freqs0 = texture2D( surfaceTex, vec2( 0.01, 0.25 ) ).x;\n")
   +string("	freqs1 = texture2D( surfaceTex, vec2( 0.07, 0.25 ) ).x;\n")
   +string("	freqs2 = texture2D( surfaceTex, vec2( 0.15, 0.25 ) ).x;\n")
   +string("//	freqs3 = texture2D( surfaceTex, vec2( 0.30, 0.25 ) ).x;\n")
   +string("	float brightness	= freqs1 * 0.25 + freqs2 * 0.25;\n")
   +string("	float radius		= 0.24 + brightness * 0.2;\n")
   +string("	float invRadius 	= 1.0/radius;	\n")
   +string("	float time		= time * 0.1;\n")
   +string("	float aspect	= 1.0;\n")
   +string("	vec2 uv			= (Texcoord.xy * 2.0 - vec2(1.0) ) / vec2(2.0);\n")
   +string("	vec2 p 			= -0.5 + uv;\n")
   +string("    vec2 moved      = ( -pos2d.xy + 0.5 );\n")
   +string("    p = p + moved;\n")
   +string("	p.x *= aspect;\n")
   +string("	float fade		= pow( length( 2.0 * p ), 0.5 );\n")
   +string("	float fVal1		= 1.0 - fade;\n")
   +string("	float fVal2		= 1.0 - fade;	\n")
   +string("	float angle		= atan( p.x, p.y )/6.2832;\n")
   +string("	float dist		= length(p);\n")
   +string("	vec3 coord		= vec3( angle, dist, t10 * 0.1 );	\n")
   +string("	float newTime1	= abs( snoise( coord + vec3( 0.0, -t10 * ( 0.35 + brightness * 0.001 ), t10 * 0.015 ), 15.0 ) );\n")
   +string("	float newTime2	= abs( snoise( coord + vec3( 0.0, -t10 * ( 0.15 + brightness * 0.001 ), t10 * 0.015 ), 45.0 ) );	\n")
   +string("	for( int i=1; i<=7; i++ ){\n")
   +string("		float power = pow( 2.0, float(i + 1) );\n")
   +string("		fVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -t10, t10 * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n")
   +string("		fVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -t10, t10 * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n")
   +string("	}	\n")
   +string("	float corona		= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n")
   +string("	corona				+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n")
   +string("	corona				*= 1.2 - newTime1;\n")
   +string("	vec3 sphereNormal 	= vec3( 0.0, 0.0, 1.0 );\n")
   +string("	vec3 dir 			= vec3( 0.0 );\n")
   +string("	vec3 center			= vec3( 0.5, 0.5, 1.0 );\n")
   +string("	vec3 starSphere		= vec3( 0.0 );    \n")
   +string("	vec2 sp = (-1.536 + 2.536 * (uv + moved + vec2(radius/2.0,radius/2.0))) ;\n")
   +string("	sp.x *= aspect;\n")
   +string("	sp *= ( 2.536 - brightness );\n")
   +string("  	float r = dot(sp,sp);\n")
   +string("	float f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n")
   +string("	if( dist < radius ){\n")
   +string("		corona			*= pow( dist * invRadius, 24.0 );\n")
   +string("  		vec2 newUv;\n")
   +string(" 		newUv.x = sp.x*f;\n")
   +string("  		newUv.y = sp.y*f;\n")
   +string("		newUv += vec2( t10, 0.0 );		\n")
   +string("		vec3 texSample 	= texture2D( sampleTex, newUv ).rgb;\n")
   +string("		float uOff		= ( texSample.g * brightness * 4.5 + t10 );\n")
   +string("		vec2 starUV		= newUv + vec2( uOff, 0.0 );\n")
   +string("		starSphere		= texture2D( sampleTex, starUV ).rgb;\n")
   +string("	}\n")
   +string("	float starGlow	= min( max( 1.0 - dist * ( 1.0 - brightness ) * glowAmount, 0.0 ), 1.0 );\n")
   +string("	//fragColor.rgb	= vec3( r );\n")
   +string("	vec3 col = vec3( f * ( 0.75 + brightness * 0.3 ) * oColor ) + starSphere + corona * oColor + starGlow * oRColor;\n")
   +string(" outColor = vec4(col,(col.r+col.g+col.b)/3.0);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void AtmosphericPlanetShader::Init() {
  OUTPUT("AtmosphericPlanetShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform vec2 pos2d;\n")
   +string("uniform float time;\n")
   +string("uniform vec3 oceanBlueColor;   // = vec3(0.0,0.031,0.11); \n")
   +string("uniform vec3 snowColor;        // = vec3(0.85,0.85,0.85)/1.85;\n")
   +string("uniform vec3 desertColor;      // = vec3(1.5,1.3,1.0)/13.0;\n")
   +string("uniform vec3 grassColor;       // = vec3(1.0,1.3,0.5)/12.0;\n")
   +string("uniform vec3 landRatios;       // = 1.85,13.0,12.0\n")
   +string("uniform vec3 cloudColor;       // = vec4(1.0,1.0,1.0)\n")
   +string("uniform float lightIntensity;  // = 4.0;\n")
   +string("uniform float landHeight;      // = 4.0;\n")
   +string("uniform float cloudComplexity; //= 2.01\n")
   +string("uniform float opacityGain;     // = 1.4;\n")
   +string("uniform float brightnessGain;  // = 0.7;\n")
   +string("uniform float haze;            // = 2.0;\n")
   +string("uniform vec3 baseAtmColor;     // = vec3(0.0,0.041,0.11)*1.5;\n")
   +string("uniform float glowIntensity;   // = 5.5\n")
   +string("uniform float glowCutoff;      // = 16.0\n")
   +string("const int steps = 8;\n")
   +string("const int nsteps = 6;\n")
   +string("const mat3 m = mat3( 0.00,  0.80,  0.60,      -0.80,  0.36, -0.48,      -0.60, -0.48,  0.64 );\n")
   +string("float hash( float n ) { return fract(sin(n)*753.5453123); }\n")
   +string("float noise( in vec3 x ) {\n")
   +string(" vec3 p = floor(x);\n")
   +string(" vec3 f = fract(x);\n")
   +string(" f = f*f*(3.0-2.0*f);\n")
   +string(" float n = p.x + p.y*157.0 + 113.0*p.z;\n")
   +string(" return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n")
   +string("                mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n")
   +string("            mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n")
   +string("                mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n")
   +string("}\n")
   +string("float cloudForm(vec3 q) {\n")
   +string(" q.x += sin(q.y*2.0);\n")
   +string(" q.z += cos(q.x*2.0)*0.3;\n")
   +string(" float f = -0.15 +\n")
   +string("  noise(q) +\n")
   +string("  noise(q*2.0) * 0.5 + \n")
   +string("  noise(q*4.0) * 0.25 +\n")
   +string("  noise(q*8.0) * 0.125 +\n")
   +string("  noise(q*16.0)* 0.05 + \n")
   +string("  noise(q*32.0)* 0.025 +\n")
   +string("  noise(q*64.0)* 0.0125;\n")
   +string(" f = min(pow(abs(f),10.0)*0.5,0.5);\n")
   +string(" return f;\n")
   +string("}\n")
   +string("float octaves6(vec3 q) {\n")
   +string(" float f = 0.0;\n")
   +string(" float ti = pow(2.0,0.0);\n")
   +string(" f += noise(q * ti ) / ti;\n")
   +string(" ti = pow(2.0,1.0);\n")
   +string(" f += noise(q * ti ) / ti;\n")
   +string(" ti = pow(2.0,2.0);\n")
   +string(" f += noise(q * ti ) / ti;\n")
   +string(" ti = pow(2.0,3.0);\n")
   +string(" f += noise(q * ti ) / ti;\n")
   +string(" ti = pow(2.0,4.0);\n")
   +string(" f += noise(q * ti ) / ti;\n")
   +string(" ti = pow(2.0,5.0);\n")
   +string(" f += noise(q * ti ) / ti;\n")
   +string(" return f;\n")
   +string("}\n")
   +string("void main() {\n")
   +string("	vec2 p =(Texcoord.xy * 2.0) - vec2(1.0);\n")
   +string("	float tmin = 10000.0;\n")
   +string("	vec3  nor = vec3(0.0);\n")
   +string("	float occ = 1.0;\n")
   +string("	vec3  pos = vec3(0.0);\n")
   +string("	float h = 0.0;\n")
   +string("	vec3 col = vec3(0.9,0.9,0.9);    \n")
   +string("	float f = 0.0;		\n")
   +string(" float isBckg=1.0;\n")
   +string("	float an = 0.5+0.02*time;                         // camera movement	\n")
   +string(" vec3 off = vec3(0.1);\n")
   +string(" vec3 bckg = vec3(0.0,0.0,0.0); \n")
   +string("	vec3 ro = vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n")
   +string(" vec3 ta = vec3( 0.0, 1.0, 0.0 );\n")
   +string(" // camera matrix\n")
   +string(" vec3 ww = normalize( ta - ro );\n")
   +string(" vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n")
   +string(" vec3 vv = normalize( cross(uu,ww));\n")
   +string("	// create view ray\n")
   +string("	vec3 rd = normalize( p.x*uu + p.y*vv + 1.7*ww );\n")
   +string(" // sphere center	\n")
   +string("	vec3 sc = vec3(0.0,1.0,0.0);\n")
   +string(" // raytrace\n")
   +string("	// raytrace-sphere\n")
   +string("	vec3  ce = ro - sc;\n")
   +string("	float b = dot( rd, ce );\n")
   +string("	float c = dot( ce, ce ) - 1.0;\n")
   +string("	h = b*b - c;\n")
   +string("	if( h>0.0 ) {\n")
   +string("		h = -b - sqrt(h);\n")
   +string("		if( h<tmin ) { \n")
   +string("			tmin=h; \n")
   +string("			nor = normalize(ro+h*rd-sc); \n")
   +string("			occ = 0.5 + 0.5*nor.y;\n")
   +string("		}\n")
   +string("	}\n")
   +string(" // shading/lighting	\n")
   +string("	pos = ro + tmin*rd;\n")
   +string(" float sunNDL = max(0.0,0.05+0.95*(nor.z));       \n")
   +string(" vec3 q = pos;            \n")
   +string(" // Ocean\n")
   +string(" col = oceanBlueColor;\n")
   +string(" col = col * (0.5 + 0.5*noise(q*4.0));\n")
   +string("	col = col * (0.9 + 0.2*noise(q*8.0));\n")
   +string(" col = col * (0.9 + 0.2*noise(q*16.0));\n")
   +string(" col = col * (0.9 + 0.1*noise(q*32.0));\n")
   +string(" col = col * (0.9 + 0.1*noise(q*64.0));            \n")
   +string(" // Land\n")
   +string(" q = m * q * 2.01;            \n")
   +string(" float hm = octaves6(q+vec3(137.0)) / 1.5;\n")
   +string(" hm *= hm;            \n")
   +string(" f = hm; \n")
   +string(" float landBlend = min(landHeight*max(f-0.3,0.0),1.0);            \n")
   +string(" float nG = exp(-abs(f-0.4)*20.0);//max(f - 0.4,0.0); \n")
   +string(" float nD = exp(-abs(f-0.6)*20.0);//3.0*max(f - 0.75,0.0); \n")
   +string(" float snowLevel = 0.8+ noise(q*64.0)*0.1;\n")
   +string(" float nS = exp(-abs(f-snowLevel)*20.0);            \n")
   +string(" vec3 snow = snowColor/landRatios.x;\n")
   +string(" vec3 desert = desertColor/landRatios.y;\n")
   +string(" vec3 grass = grassColor/landRatios.z;            \n")
   +string("	float normn = nG + nD + nS;            \n")
   +string(" float grassD = 1.0 + (noise(q*128.0) + noise(q*64.0) + noise(q*32.0))*0.5;            \n")
   +string(" float snowD = 1.0 + (noise(q*vec3(5.0,1.0,1.0)*3.0)  + noise(q*16.0)*0.5 + noise(q*64.0)*0.5)*0.25;            \n")
   +string(" float desertD = 1.0 + noise(q*vec3(1.0,7.0,1.0)*3.0) + noise(q*32.0)*0.5 + noise(q*64.0)*0.5;            \n")
   +string(" vec3 land = (desertD*desert*nD + grassD*grass*nG + snowD*snow*nS)/normn;\n")
   +string(" col = mix(col,land,landBlend);            \n")
   +string(" float shore = clamp(1.42*pow(1.0-abs(landBlend-0.4),1.0)-1.2,0.0,1.0);\n")
   +string(" col = mix(col, col + vec3(0.0,0.1,0.05),shore);\n")
   +string(" // Cloud shadows\n")
   +string(" q = m * q * cloudComplexity + time*0.03;\n")
   +string("	f = cloudForm(q+off);\n")
   +string(" f = 0.2 + 0.8*pow(1.0 - f*0.75,2.0);\n")
   +string(" col = col * f;            \n")
   +string("	f = cloudForm(q);  // Clouds  \n")
   +string("	float cloudAmount=min(f*opacityGain,1.0);\n")
   +string(" vec3 cloudCol =	cloudColor * ( vec3(0.2)+0.7*noise(q*2.0)+0.4*noise(q*6.0)+0.2*noise(q*16.0)+0.05*noise(q*32.0)+0.04*noise(q*64.0) ); \n")
   +string(" cloudCol = (cloudCol + f*0.05)*0.55;\n")
   +string(" col = mix(col,cloudCol*brightnessGain,cloudAmount);            \n")
   +string(" float depth = tmin * 2.7 / 2.0;                // Depth\n")
   +string("	col *= (0.005 + sunNDL * lightIntensity);      // Surface Diffuse Lighting\n")
   +string(" vec3 ref = reflect(nor,-vec3(0.0,0.0,-1.0));   // Surface Specular\n")
   +string(" float sunRDE = max(dot(ref,rd),0.0);\n")
   +string(" float spec = 0.125*pow(sunRDE,512.0);\n")
   +string(" col += spec*mix(col,vec3(1.0),0.05)*sunNDL;        \n")
   +string(" float atm = -max(-1.0,1.1 - depth);           // Inner Atmosphere\n")
   +string(" col = mix(col,baseAtmColor*sunNDL*lightIntensity,pow(atm,haze));\n")
   +string(" float glow = 0.0;                             // Atmosphere glow\n")
   +string(" const float di = (128.0/50.0)/float(steps);\n")
   +string(" for(float i = 0; i < steps; ++i)\n")
   +string(" {\n")
   +string("  vec3 px = ro + rd * (i)*di;\n")
   +string("  vec3 tosc = sc - px;\n")
   +string("  float d = length(tosc);\n")
   +string("  float x = abs(d - 1.0);\n")
   +string("  float n = 0.01+max((-tosc/d).z,0.0);\n")
   +string("  glow += glowIntensity * exp(-x*glowCutoff) * n * di;\n")
   +string(" }\n")
   +string(" vec3 glowCol = glow * baseAtmColor;        \n")
   +string(" bckg = bckg + glowCol; // Background\n")
   +string(" isBckg = 1.0-exp( -0.00001*tmin*tmin );\n")
   +string("	col = mix( col,bckg, isBckg );\n")
   +string("	col = sqrt( col);	\n")
   +string("	//col *= smoothstep( 0.006, 0.008, abs(p.x) );	\n")
   +string("	outColor = vec4( col, 1.0-isBckg );\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void Earthlike2Shader::Init() {
  OUTPUT("Earthlike2Shader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform sampler2D tex;\n")
   +string("uniform sampler2D tex2;\n")
   +string("uniform float time;\n")
   +string("uniform vec2 rotation;\n")
   +string("uniform vec4 planetParams;\n")
   +string("uniform vec4 planetParams2;\n")
   +string("uniform vec4 planetParams3;\n")
   +string("uniform vec3 surfaceThresholdColor;   // .2, .9, .5\n")
   +string("uniform vec3 secondaryMaterialColor;  // 0.3, 0.3, 0.3\n")
   +string("uniform float specular;               //=0.03\n")
   +string("uniform vec3 specularPos;             //=vec3(0.9,0.3,1.0)\n")
   +string("uniform vec3 ambientColor;            //=vec3(0.1,0.1,0.1);\n")
   +string("uniform vec3 atmosphereDiffuseColor;  //=vec3(0.4,0.0,1.0)\n")
   +string("uniform vec3 atmosphereSpecularColor; //=vec3(0.7,0.9,1.0)\n")
   +string("uniform vec3 darkDiffuseColor;        //=vec3(0.20,0.10,0.05)\n")
   +string("uniform vec3 darkSpecularColor;       //=vec3(0.20,0.10,0.05)\n")
   +string("uniform vec3 oceanColor;              //=vec3(0.2,0.3,0.4);\n")
   +string("uniform float diffusion;              //=0.75\n")
   +string("uniform float zoom;                   //=2.5\n")
   +string("uniform float cloudset;               //=2.0\n")
   +string("uniform float landset;                //=0.5\n")
   +string("vec4 doit( vec2 pix ) {\n")
   +string(" vec2 p = -1.0 + 2.0*pix;\n")
   +string(" vec3 ro = vec3( 0.0, 0.0, zoom );\n")
   +string(" vec3 rd = normalize( vec3( p, -2.0 ) );\n")
   +string(" vec3 col = ambientColor;\n")
   +string(" // intersect sphere\n")
   +string(" float b = dot(ro,rd);\n")
   +string(" float c = dot(ro,ro) - 1.0;\n")
   +string(" float h = b*b - c;\n")
   +string(" if( h>0.0 ) {\n")
   +string("     float t = -b - sqrt(h);\n")
   +string("     vec3 pos = ro + t*rd;\n")
   +string("     vec3 nor = pos;\n")
   +string("     vec2 uv;\n")
   +string("     uv.x = atan(nor.x,nor.z)/6.2831 - 0.03*time - rotation.x;\n")
   +string("     uv.y = acos(nor.y)/3.1416;\n")
   +string(" 	   uv.y *= 0.5;\n")
   +string("     col = oceanColor;\n")
   +string("     vec3 te  = texture2D( tex2, landset*uv.yx ).xyz;\n")
   +string("          te += planetParams.x*texture2D( tex2, planetParams.y*uv.yx ).xyz;\n")
   +string(" 	   col = mix( col, (surfaceThresholdColor*planetParams.z + planetParams.w*te + planetParams2.x*texture2D( tex, planetParams2.y*uv.yx ).xyz)*planetParams2.z, smoothstep( planetParams2.w,planetParams3.x,te.x) );\n")
   +string("     vec3 cl = texture2D( tex, cloudset*uv ).xxx;\n")
   +string(" 	   col = mix( col, secondaryMaterialColor, planetParams3.z*smoothstep( planetParams3.y,planetParams3.w,cl.x) );	\n")
   +string("     float dif = max(nor.x*2.0+nor.z,0.0);\n")
   +string("     float fre = 1.0-clamp(nor.z,0.0,1.0);\n")
   +string("     float spe = clamp( dot( nor,normalize(specularPos) ), 0.0, 1.0 );\n")
   +string("     col *= specular + diffusion*dif;\n")
   +string("     col += pow(spe,64.0)*(1.0-te.x);\n")
   +string("     col += mix( darkDiffuseColor, atmosphereDiffuseColor, dif )*0.3*fre;\n")
   +string("     col += mix( darkSpecularColor, atmosphereSpecularColor, dif )*7.0*fre*fre*fre*fre;\n")
   +string(" } else return vec4(0.0,0.0,0.0,0.0);\n")
   +string(" col = vec3(0.5)*(col+sqrt(col));\n")
   +string(" return vec4(col,1.0);\n")
   +string("}\n")
   +string("void main() { \n")
   +string("    // render this with four sampels per pixel\n")
   +string("    vec4 col0 = doit( (Texcoord.xy+vec2(0.0,0.0) ) );\n")
   +string("    vec4 col1 = doit( (Texcoord.xy+vec2(0.0,0.0) ) );\n")
   +string("    vec4 col2 = doit( (Texcoord.xy+vec2(0.0,0.0) ) );\n")
   +string("    vec4 col3 = doit( (Texcoord.xy+vec2(0.0,0.0) ) );\n")
   +string("    vec4 col = vec4(0.25)*(col0 + col1 + col2 + col3);\n")
   +string("    outColor = col;\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void RingedJovian2Shader::Init() {
  OUTPUT("RingedJovian2Shader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform float time;\n")
   +string("uniform sampler2D noiseTex;\n")
   +string("uniform vec3 cameraPos;         //=vec3(20,1.5,1); vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) ); }\n")
   +string("uniform float rotation; \n")
   +string("uniform float roll; // = -200; // = 0.3*sin(1.0+0.001*t);\n")
   +string("uniform vec3 lightPos;          //=vec3 lig = normalize( vec3(0.3,0.9,0.7) );\n")
   +string("uniform float bumpiness;        //=1.0;\n")
   +string("uniform vec3 color1;            //=vec3(0.8,0.6,0.0)\n")
   +string("uniform vec3 color2;            //=vec3(0.7,0.7,1.0)\n")
   +string("uniform vec3 albedoColor;       //=vec3(0,0.5,0.8)\n")
   +string("uniform vec3 ringColor1;        //=vec3(1.0, 0.3, 0.0)\n")
   +string("uniform vec3 ringColor2;        //=vec3(1.0, 0.2, 0.0),\n")
   +string("uniform vec3 centerGlowColor;   //=vec3(1,0.8,0.5)\n")
   +string("uniform float amb;              //= 2.5;  // ambient gain\n")
   +string("uniform float ringRadRatio;     //= 2.1; multiple of satradius\n")
   +string("uniform float bandFreq;         //= 8.0; \n")
   +string("uniform vec3 diffuseColor;      //=vec3(0.8);\n")
   +string("uniform vec4 ringParams;        //=vec3(1.2,0.9,573.62,0.4)\n")
   +string("const int marches=12;           // was 160\n")
   +string("const int shadow_precision=12;  // was 48\n")
   +string("const float PI = 3.1415926535897932384626433832795;\n")
   +string("const float TPI = 2.0 * PI;\n")
   +string("const mat3 m = mat3( 0.00,  0.80,  0.60,   -0.80,  0.36, -0.48,   -0.60, -0.48,  0.64 );  // I think this is just a rotation matrix - haven't analyzed it really.\n")
   +string("const float satradius = 5.0;\n")
   +string("const float satRotSpeed = 3.14*0.01;\n")
   +string("const float lodbias=0.0;\n")
   +string("vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n")
   +string("vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n")
   +string("vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n")
   +string("vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n")
   +string("vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n")
   +string("float snoise2d(vec2 v) {\n")
   +string(" const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n")
   +string("                     0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n")
   +string("                    -0.577350269189626,  // -1.0 + 2.0 * C.x\n")
   +string("                     0.024390243902439); // 1.0 / 41.0\n")
   +string(" vec2 i  = floor(v + dot(v, C.yy) );\n")
   +string(" vec2 x0 = v -   i + dot(i, C.xx);\n")
   +string(" vec2 i1;\n")
   +string(" i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n")
   +string(" vec4 x12 = x0.xyxy + C.xxzz;\n")
   +string(" x12.xy -= i1;\n")
   +string(" i = mod289(i); // Avoid truncation effects in permutation\n")
   +string(" vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n")
   +string(" 	+ i.x + vec3(0.0, i1.x, 1.0 ));\n")
   +string(" vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n")
   +string(" m = m*m ;\n")
   +string(" m = m*m ;\n")
   +string(" vec3 x = 2.0 * fract(p * C.www) - 1.0;\n")
   +string(" vec3 h = abs(x) - 0.5;\n")
   +string(" vec3 ox = floor(x + 0.5);\n")
   +string(" vec3 a0 = x - ox;\n")
   +string(" m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n")
   +string(" vec3 g;\n")
   +string(" g.x  = a0.x  * x0.x  + h.x  * x0.y;\n")
   +string(" g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n")
   +string(" return 130.0 * dot(m, g);\n")
   +string("}\n")
   +string("float snoise1d(float x) { return snoise2d(vec2(0.0, x)); }\n")
   +string("float noise( vec3 x ) {\n")
   +string("    vec3 p = floor(x);\n")
   +string("    vec3 f = fract(x);\n")
   +string("	f = f*f*(3.0-2.0*f);	\n")
   +string("	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n")
   +string("	vec2 rg = texture2D( noiseTex, (uv+ 0.5)/256.0, -100.0 ).yx;\n")
   +string("	return mix( rg.x, rg.y, f.z );\n")
   +string("}\n")
   +string("float noise( vec2 x ) { vec2 p = floor(x); vec2 f = fract(x);	vec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);	return texture2D( noiseTex, (uv+118.4)/256.0, -100.0 ).x; } \n")
   +string("vec4 texcube( sampler2D sam, in vec3 p, in vec3 n ) { \n")
   +string("	vec4 x = texture2D( sam, p.yz, lodbias );\n")
   +string("	vec4 y = texture2D( sam, p.zx, lodbias );\n")
   +string("	vec4 z = texture2D( sam, p.xy, lodbias );\n")
   +string("	return x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n")
   +string("}\n")
   +string("float displacement( vec3 p ) { \n")
   +string("    float f = 0.5000*noise( p ); p = m*p*2.02; \n")
   +string("    f += 0.2500*noise( p ); p = m*p*2.03; \n")
   +string("    f += 0.1250*noise( p ); p = m*p*2.01; \n")
   +string("    f += 0.0625*noise( p ); \n")
   +string("	float n = noise( p*5.5 ); \n")
   +string("    f += 0.03*n*n; \n")
   +string("    return f; \n")
   +string("}\n")
   +string("vec3 yRot( vec3 p, float rads ) {\n")
   +string("    return vec3(\n")
   +string("        p.x*cos(rads) - p.z*sin(rads),\n")
   +string("        p.y,\n")
   +string("        p.x*sin(rads) + p.z*cos(rads) );\n")
   +string("}\n")
   +string("float planetSDF( vec3 p ) {\n")
   +string(" p = yRot(p, time*satRotSpeed);\n")
   +string("	vec3 spotDir = normalize(vec3(0.0,1.0,0.0));\n")
   +string("	float noisePart = bumpiness * 0.005 * noise(5.0*p) * sin(3.0*bandFreq*dot(normalize(p),spotDir));\n")
   +string("	return length(p) - satradius + noisePart;\n")
   +string("}\n")
   +string("float unionn( float a, float b ) { return min(a,b); }\n")
   +string("float subtract( float a, float b ) { return max(-a, b); }\n")
   +string("float intersect( float a, float b ) { return max(a, b); }\n")
   +string("float raymarchTerrain( vec3 ro, vec3 rd ) {\n")
   +string("	float maxd = 30.0;\n")
   +string("	float precis = 0.001;						\n")
   +string("    float distToSurf = 1.0;\n")
   +string("    float t = 0.1;\n")
   +string("    for( int i=0; i<marches; i++ )\n")
   +string("    {\n")
   +string("     if( abs(distToSurf)<precis||t>maxd ) continue;//break;\n")
   +string("	    distToSurf = planetSDF( ro+rd*t );\n")
   +string("     t += distToSurf;\n")
   +string("    }\n")
   +string("    if( t>maxd ) t=-1.0;\n")
   +string("    return t;\n")
   +string("}\n")
   +string("vec3 calcNormal( in vec3 pos )\n")
   +string("{\n")
   +string("    vec3 eps = vec3(0.02,0.0,0.0);\n")
   +string("	return normalize( vec3(\n")
   +string("           planetSDF(pos+eps.xyy) - planetSDF(pos-eps.xyy),\n")
   +string("           planetSDF(pos+eps.yxy) - planetSDF(pos-eps.yxy),\n")
   +string("           planetSDF(pos+eps.yyx) - planetSDF(pos-eps.yyx) ) );\n")
   +string("\n")
   +string("}\n")
   +string("float softshadow( vec3 ro, vec3 rd, float mint, float k )\n")
   +string("{\n")
   +string("    float res = 1.0;\n")
   +string("    float t = mint;\n")
   +string("    for( int i=0; i<shadow_precision; i++ )\n")
   +string("    {\n")
   +string("        float h = planetSDF(ro + rd*t);\n")
   +string("		h = max( h, 0.0 );\n")
   +string("        res = min( res, k*h/t );\n")
   +string("        t += clamp( h, 0.02, 0.5 );\n")
   +string("    }\n")
   +string("    return clamp(res,0.0,1.0);\n")
   +string("}\n")
   +string("float density=0.0; \n")
   +string("vec3 blendrings( vec3 col, float t, vec3 ro, vec3 rd ) {\n")
   +string(" float ringrad = satradius*ringRadRatio;    \n")
   +string(" float tring = -ro.y/rd.y;\n")
   +string(" vec3 pring = ro + tring*rd;\n")
   +string(" pring = yRot(pring, time*PI/20.);\n")
   +string(" float r = length(pring.xz);    \n")
   +string(" if( (tring < t || t <= 0.0) && r <= ringrad )\n")
   +string(" {\n")
   +string("  float noise = snoise1d(r*0.4 + ringParams.z);\n")
   +string("  float normnoise = noise * 0.5 + 0.5;\n")
   +string("  float edgesoft = 0.1;\n")
   +string("  float denstart = ringParams.w;\n")
   +string("  density = smoothstep(denstart, denstart+edgesoft, normnoise);\n")
   +string("  // more high freq radial noise on top\n")
   +string("  density += snoise1d(r*0.8)*0.3;\n")
   +string("  density = clamp(density, 0., 1.);\n")
   +string("  // soften outer edge\n")
   +string("  density *= 1.0 - smoothstep(ringrad*0.98, ringrad, r);\n")
   +string("  // soften inner edge, against planet\n")
   +string("  density *= smoothstep(satradius, satradius*1.05, r);\n")
   +string("  vec3 ringcol = mix( ringColor1, ringColor2, snoise1d(r)*0.5+0.5 );\n")
   +string("  ringcol = mix(vec3(0.0,0.0,0.0), ringcol, pow(r/ringrad,2.0));\n")
   +string("  ringcol *= mix(0.95, 1.0, snoise2d(pring.xz*5.));\n")
   +string("  // darken towards the middle\n")
   +string("  ringcol *= smoothstep(ringrad-satradius*ringParams.x, ringrad, r);   \n")
   +string("  ringcol *= ringParams.y;\n")
   +string("  //col += density*ringcol;\n")
   +string("  col = mix( col, ringcol.xyz, density);\n")
   +string(" }\n")
   +string(" return col;\n")
   +string("}\n")
   +string("vec2 curl2d(vec2 p) {\n")
   +string(" const float E = 0.9;\n")
   +string(" float x = snoise2d(p);\n")
   +string(" float xey = snoise2d(p+vec2(0., E));\n")
   +string(" float xex = snoise2d(p+vec2(E, 0.));\n")
   +string(" return vec2( xex-x, -(xey-x) ) / E;\n")
   +string("}\n")
   +string("vec3 saturn_gradient(vec3 pos, vec3 rd) {\n")
   +string(" vec3 albedo = mix( color1, color2, snoise2d( vec2(0.0, pos.y*1.2) ) );    \n")
   +string(" albedo += albedoColor * smoothstep(0.0, -2.0, pos.y);  \n")
   +string(" return albedo;\n")
   +string("}\n")
   +string("vec3 shade_saturn(vec3 pos, vec3 rd ) {\n")
   +string(" float t = time;\n")
   +string(" vec3 p = pos;    \n")
   +string(" p = yRot(p, time * PI/20.);     // rotate the flow map a bit\n")
   +string(" // to spherical\n")
   +string(" float r = length(p);\n")
   +string(" float phi = atan(p.x, p.z);\n")
   +string(" float theta = acos(p.y/r);\n")
   +string(" vec2 uv = vec2( phi/PI - 0.5, -(theta/PI - 0.5) );    // to UV\n")
   +string(" for( int i = 0; i < 20; i++ ) {    // backwards curl advection\n")
   +string("  vec2 duv = curl2d(uv*20.)*.0004*.5;\n")
   +string("  uv += duv;\n")
   +string(" }\n")
   +string(" // back to spherical\n")
   +string(" phi = (uv.x+0.5) * PI;\n")
   +string(" theta = (-uv.y+0.5) * PI;\n")
   +string(" theta += sin(TPI*phi/(0.1*PI) + t*(1.3*PI)) * PI*0.005;    // add some ripple in opposite direction so it can flow through the warp\n")
   +string(" // back to cartesian\n")
   +string(" p = vec3(\n")
   +string(" r * sin(theta) * cos(phi),\n")
   +string(" r * cos(theta),\n")
   +string(" r * sin(theta) * sin(phi));\n")
   +string(" vec3 alb = saturn_gradient( p, rd );    \n")
   +string(" // make the center glow a bit\n")
   +string("	vec3 nor = pos/length(pos);    \n")
   +string(" alb += centerGlowColor * smoothstep(1.5, 0.0, abs(pos.y)) * pow(dot(nor,-rd),1.0);\n")
   +string(" return alb;\n")
   +string("}\n")
   +string("vec2 hash( vec2 p ) { return texture2D( noiseTex, (p+0.5)/200.0, -100.0 ).xy; }\n")
   +string("void main() {\n")
   +string(" vec3 lig = normalize(lightPos);")
   +string(" vec2 q = Texcoord.xy;\n")
   +string("	vec2 p = -1.0 + 2.0*q;\n")
   +string(" // camera	\n")
   +string("	float t = 2.7+time;\n")
   +string(" t *= 0.1;    // TEMP freeze camera\n")
   +string("	vec3 ro = cameraPos;\n")
   +string("	vec3 camTarget = cameraPos;\n")
   +string("	camTarget = vec3(0,0,0);\n")
   +string("	ro = normalize(ro)*max( 10.0, length(ro)); // stop entering planet\n")
   +string("	vec3 cw = normalize(camTarget-ro);\n")
   +string("	vec3 cp = vec3(sin(roll), cos(roll),rotation);\n")
   +string("	vec3 cu = normalize(cross(cw,cp)); \n")
   +string("	vec3 cv = normalize(cross(cu,cw)); \n")
   +string("	float r2 = p.x*p.x*0.32 + p.y*p.y; \n")
   +string(" p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0); \n")
   +string("	vec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw ); \n")
   +string("	vec3 col = vec3(0.0,0.0,0.0); \n")
   +string(" col *= 0.9;    \n")
   +string("	vec3 bcol = col;\n")
   +string("	float ter = raymarchTerrain(ro, rd)+0.0;    // terrain	\n")
   +string(" if( ter>0.0 )	{ // we've hit saturn        \n")
   +string("		vec3 pos = ro + ter*rd; \n")
   +string("		vec3 nor = calcNormal( pos ); \n")
   +string("		vec3 ref = reflect( rd, nor ); \n")
   +string("		vec3 bn = -1.0 + 2.0*texcube( noiseTex, 3.0*pos/4.0, nor ).xyz; \n")
   +string("		nor = normalize( nor + 0.2*bn );		\n")
   +string("		float hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n")
   +string("        // lighting\n")
   +string("		float dif = sqrt(clamp( dot( nor, lig ), 0.0, 1.0 ));\n")
   +string("		float sha = 0.0;\n")
   +string("		if( dif>0.01)\n")
   +string("			sha=softshadow(pos,lig,0.01,32.0);\n")
   +string("		float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n")
   +string("		float sky = 0.5 + 0.5*nor.y;\n")
   +string("		float occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n")
   +string("		col = diffuseColor;\n")
   +string("		float cd = length(pos);\n")
   +string("  vec3 albedo = shade_saturn(pos, rd);        // shade Saturn\n")
   +string("  vec3 brdf =	dif * albedo;\n")
   +string("  brdf += 0.1 * amb * albedo;\n")
   +string("  brdf -= pow(1.0-clamp(dot(nor,-rd),0.,1.),1.9);        // anti-rim lighting\n")
   +string("  col = brdf * col;                        // light/surface interaction		\n")
   +string("		col = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );		// atmospheric\n")
   +string("  col = blendrings(col, ter, ro, rd);        // rings - ray trace directly on to the y=0 plane\n")
   +string("  col *= mix(0.95, 1.0, snoise2d(p*50.0)); // film grain over everything\n")
   +string("	 outColor = vec4( col, 1.0 );\n")
   +string("	} else {\n")
   +string("  col = vec3( 0.0,0.0,0.0 ); \n")
   +string("  col = blendrings(col, ter, ro, rd);        // rings - ray trace directly on to the y=0 plane\n")
   +string("	 outColor = vec4(col,density);\n")
   +string(" }\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void LunarPlanetShader::Init() {
  OUTPUT("LunarPlanetShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")+
    string("uniform float time;\n")
   +string("uniform vec2 pos2d;       //=iMouse.xy/iResolution.xy;\n")
   +string("uniform vec2 offSet;         //=vec2(0.6, 0.0);\n")
   +string("uniform vec2 texScale;       //=vec2(1.0,1.0);\n")
   +string("uniform vec3 origin;         //=vec3(0.0,0.0,-2.5);\n")
   +string("uniform vec4 baseColor;      //=vec4(0.7,0.8,1.0, 1.0);\n")
   +string("uniform vec4 multiplyColor;  //=vec4(0.9,0.55,0.9, 1.0);\n")
   +string("uniform float heightFactor;  //=0.6;\n")
   +string("uniform float scaleFactor;   //=1.0;\n")
   +string("uniform float rotationSpeed; //=-0.05;\n")
   +string("uniform float zScale;        //=3.5;\n")
   +string("uniform float smoothness;    //=0.01;\n")
   +string("uniform vec4 ambientColor;   //=vec4(0.2, 0.0, 0.05, 1.0);\n")
   +string("uniform vec3 lightPos;       // = vec3(1.0, 0.0, -1.0);\n")
   +string("uniform sampler2D tex;\n")
   +string("const float PI = 3.14159265358979323846264338327950288419;\n")
   +string("vec2 sphere_map(vec3 n) { return texScale * (vec2((atan(n.z,n.x)/(2.0 * PI)) + time * rotationSpeed, acos(n.y) / (PI))) + offSet; }\n")
   +string("float scene(vec3 p) {\n")
   +string(" vec2 uv = sphere_map(normalize(p));\n")
   +string(" return length(p)-(scaleFactor*0.3 - pow(texture2D(tex, uv).x, 0.7) * (heightFactor*0.1));\n")
   +string("}\n")
   +string("vec3 getNormal(vec3 ray_hit_position, float smoothness) {	\n")
   +string(" vec3 n;\n")
   +string(" vec2 dn = vec2(smoothness, 0.0);\n")
   +string(" n.x	= scene(ray_hit_position + dn.xyy) - scene(ray_hit_position - dn.xyy);\n")
   +string(" n.y	= scene(ray_hit_position + dn.yxy) - scene(ray_hit_position - dn.yxy);\n")
   +string(" n.z	= scene(ray_hit_position + dn.yyx) - scene(ray_hit_position - dn.yyx);\n")
   +string(" return normalize(n);\n")
   +string("}\n")
   +string("float raymarch(vec3 pos3d, vec3 direction) {\n")
   +string(" float total_distance = 0.0;\n")
   +string(" for(int i = 0 ; i < 32 ; ++i) {\n")
   +string("  float result = scene(pos3d + direction * total_distance);\n")
   +string("  if(result < 0.005) { return total_distance; }\n")
   +string("  total_distance += result;\n")
   +string(" }\n")
   +string(" return -1.0;\n")
   +string("}\n")
   +string("void main() {\n")
   +string("vec2 uv =  (Texcoord.xy * 2.0 - vec2(1.0) ) / vec2(2.0);\n")
   +string("vec3 direction = normalize(vec3(uv, zScale));\n")
   +string(" float dist = raymarch(origin, direction);\n")
   +string(" if(dist < 0.0) {\n")
   +string("  outColor = vec4(0.0,0.0,0.0,0.0); \n")
   +string(" } else{\n")
   +string("  vec3 fragPosition = origin+direction*dist;\n")
   +string("  vec3 N = getNormal(fragPosition, smoothness);\n")
   +string("  float diffuse = dot(normalize(lightPos), N);\n")
   +string("  diffuse = max(0.0, diffuse); \n")
   +string("  vec2 uv = sphere_map(normalize(fragPosition));\n")
   +string("  vec4 cheeseColor = baseColor - texture2D(tex, uv).x * multiplyColor;\n")
   +string("  outColor = (cheeseColor*diffuse)+ambientColor+pow(max(0.0,dot(normalize(-reflect(fragPosition-lightPos, N)),normalize(-fragPosition))), 80.0) ;\n")
   +string(" }\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


 
 void FlaringStarShader::Init() {
  OUTPUT("FlaringStarShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform float time;\n")
   +string("uniform float scaleStar;          // =1.25;\n")
   +string("uniform float scaleClamp;         // =1.5;\n")
   +string("uniform float invCircleWidth;     // =0.25;\n")
   +string("uniform float rays_innerR;        // =0.96;\n")
   +string("uniform float rays_outerR;        // =2.0;\n")
   +string("uniform vec2 pos2d;            // = vec2(0.5,0.5);\n")
   +string("uniform vec2 rotation;            // = vec2(iGlobalTime*0.1,0);\n")
   +string("uniform vec3 convectiveColor;     // = vec3(0.5,0.0,0.0);\n")
   +string("uniform vec3 surfaceStaticColor;  // = vec3(0.0,1.0,1.0);\n")
   +string("uniform vec3 surfaceStaticColor2; // = vec3(1.0,1.0,1.0);\n")
   +string("uniform vec3 surfaceColor1;       // = vec3(1.0,0.0,0.0);\n")
   +string("uniform vec3 surfaceColor2;       // = vec3(1.0,1.0,0.0);\n")
   +string("uniform vec3 tintColor;           // = vec3(1.0,1.0,1.0);\n")
   +string("uniform vec3 coronaColor;         // = vec3(1.0,1.0,1.0);\n")
   +string("uniform vec3 plasmaColor;         // = vec3(1.0,0.6,0.1);\n")
   +string("uniform vec3 windColor1;          // = vec3(1.0,0.0,0.0);\n")
   +string("uniform vec3 windColor2;          // = vec3(0.0,0.0,1.0);\n")
   +string("uniform vec3 windColor3;          // = vec3(0.9,1.0,0.1);\n")
   +string("vec4 hash4( vec4 n ) { return fract(sin(n)*1399763.5453123); }\n")
   +string("vec3 hash3( vec3 n ) { return fract(sin(n)*1399763.5453123); }\n")
   +string("vec3 hpos( vec3 n ) { return hash3(vec3(dot(n,vec3(157.0,113.0,271.0)),dot(n,vec3(271.0,157.0,113.0)),dot(n,vec3(113.0,271.0,157.0)))); }\n")
   +string("float noise4q(vec4 x)\n")
   +string("{\n")
   +string("	vec4 n3 = vec4(0,0.25,0.5,0.75);\n")
   +string("	vec4 p2 = floor(x.wwww+n3);\n")
   +string("	vec4 b = floor(x.xxxx+n3) + floor(x.yyyy+n3)*157.0 + floor(x.zzzz +n3)*113.0;\n")
   +string("	vec4 p1 = b + fract(p2*0.00390625)*vec4(164352.0, -164352.0, 163840.0, -163840.0);\n")
   +string("	p2 = b + fract((p2+1.0)*0.00390625)*vec4(164352.0, -164352.0, 163840.0, -163840.0);\n")
   +string("	vec4 f1 = fract(x.xxxx+n3);\n")
   +string("	vec4 f2 = fract(x.yyyy+n3);\n")
   +string("	f1=f1*f1*(3.0-2.0*f1);\n")
   +string("	f2=f2*f2*(3.0-2.0*f2);\n")
   +string("	vec4 n1 = vec4(0,1.0,157.0,158.0);\n")
   +string("	vec4 n2 = vec4(113.0,114.0,270.0,271.0);	\n")
   +string("	vec4 vs1 = mix(hash4(p1), hash4(n1.yyyy+p1), f1);\n")
   +string("	vec4 vs2 = mix(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1);\n")
   +string("	vec4 vs3 = mix(hash4(p2), hash4(n1.yyyy+p2), f1);\n")
   +string("	vec4 vs4 = mix(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);	\n")
   +string("	vs1 = mix(vs1, vs2, f2);\n")
   +string("	vs3 = mix(vs3, vs4, f2);\n")
   +string("	vs2 = mix(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n")
   +string("	vs4 = mix(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n")
   +string("	vs2 = mix(vs2, vs4, f2);\n")
   +string("	vs4 = mix(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n")
   +string("	vec4 vs5 = mix(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n")
   +string("	vs4 = mix(vs4, vs5, f2);\n")
   +string("	f1 = fract(x.zzzz+n3);\n")
   +string("	f2 = fract(x.wwww+n3);\n")
   +string("	f1=f1*f1*(3.0-2.0*f1);\n")
   +string("	f2=f2*f2*(3.0-2.0*f2);\n")
   +string("	vs1 = mix(vs1, vs2, f1);\n")
   +string("	vs3 = mix(vs3, vs4, f1);\n")
   +string("	vs1 = mix(vs1, vs3, f2);\n")
   +string("	float r=dot(vs1,vec4(0.25));\n")
   +string("	return r*r*(3.0-2.0*r);\n")
   +string("}\n")
   +string("float starBody(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise,float anim)\n")
   +string("{\n")
   +string("  	float b = dot(ray,pos);\n")
   +string("  	float c = dot(pos,pos) - b*b;    \n")
   +string("    vec3 r1=vec3(0.0);    \n")
   +string("    float s=0.0;\n")
   +string("    float d=0.03125;\n")
   +string("    float d2=zoom/(d*d); \n")
   +string("    float ar=5.0;   \n")
   +string("    for (int i=0;i<3;i++) {\n")
   +string("		float rq=r*r;\n")
   +string("        if(c <rq) {\n")
   +string("            float l1=sqrt(rq-c);\n")
   +string("            r1= ray*(b-l1)-pos;\n")
   +string("            r1=r1*mr;\n")
   +string("            s+=abs(noise4q(vec4(r1*d2+subnoise*ar,anim*ar))*d);\n")
   +string("        }\n")
   +string("        ar-=2.0;\n")
   +string("        d*=4.0;\n")
   +string("        d2*=0.0625;\n")
   +string("        r=r-r*0.02;\n")
   +string("    }\n")
   +string("    return s;\n")
   +string("}\n")
   +string("// glow ring\n")
   +string("float ring(vec3 ray,vec3 pos,float r,float size) {\n")
   +string("  	float b = dot(ray,pos);\n")
   +string("  	float c = dot(pos,pos) - b*b;   \n")
   +string("    float s=max(0.0,(1.0-size*abs(r-sqrt(c))));    \n")
   +string("    return s;\n")
   +string("}\n")
   +string("// rays of a star\n")
   +string("float ringRayNoise(vec3 ray,vec3 pos,float r,float size,mat3 mr,float anim) {\n")
   +string("  	float b = dot(ray,pos);\n")
   +string("    vec3 pr=ray*b-pos;       \n")
   +string("    float c=length(pr);\n")
   +string("    pr*=mr;    \n")
   +string("    pr=normalize(pr);    \n")
   +string("    float s=max(0.0,(1.0-size*abs(r-c)));    \n")
   +string("    float nd=noise4q(vec4(pr*1.0,-anim+c))*2.0;\n")
   +string("    nd=pow(nd,2.0);\n")
   +string("    float n=0.4;\n")
   +string("    float ns=1.0;\n")
   +string("    if (c>r) {\n")
   +string("        n=noise4q(vec4(pr*10.0,-anim+c));\n")
   +string("        ns=noise4q(vec4(pr*50.0,-anim*2.5+c*2.0))*2.0;\n")
   +string("    }\n")
   +string("    n=n*n*nd*ns;    \n")
   +string("    return pow(s,4.0)+s*s*n;\n")
   +string("}\n")
   +string("vec4 noiseSpace(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise,float anim){\n")
   +string("  	float b = dot(ray,pos);\n")
   +string("  	float c = dot(pos,pos) - b*b;    \n")
   +string("    vec3 r1=vec3(0.0);    \n")
   +string("    float s=0.0;\n")
   +string("    float d=0.0625*1.5;\n")
   +string("    float d2=zoom/d;\n")
   +string("	float rq=r*r;\n")
   +string("    float l1=sqrt(abs(rq-c));\n")
   +string("    r1= (ray*(b-l1)-pos)*mr;\n")
   +string("    r1*=d2;\n")
   +string("    s+=abs(noise4q(vec4(r1+subnoise,anim))*d);\n")
   +string("    s+=abs(noise4q(vec4(r1*0.5+subnoise,anim))*d*2.0);\n")
   +string("    s+=abs(noise4q(vec4(r1*0.25+subnoise,anim))*d*4.0);\n")
   +string("    //return s;\n")
   +string("    return vec4(s*2.0,abs(noise4q(vec4(r1*0.1+subnoise,anim))),abs(noise4q(vec4(r1*0.1+subnoise*6.0,anim))),abs(noise4q(vec4(r1*0.1+subnoise*13.0,anim))));\n")
   +string("}\n")
   +string("float sphereZero(vec3 ray,vec3 pos,float r) {\n")
   +string("  	float b = dot(ray,pos);\n")
   +string("  	float c = dot(pos,pos) - b*b;\n")
   +string("    float s=1.0;\n")
   +string("    if (c<r*r) s=0.0;\n")
   +string("    return s;\n")
   +string("}\n")
   +string("void main() {\n")
   +string(" vec2 uv =  (Texcoord.xy - vec2(0.75) );\n")
   +string("	vec2 p = uv.xy * scaleStar;\n")
   +string("	vec2 q = uv.xy * scaleClamp;\n")
   +string("	float mx = pos2d.x>0.0?pos2d.x*10.0:0.5;\n")
   +string(" float my = pos2d.y>0.0?pos2d.y*4.0-2.0:0.0;\n")
   +string(" vec2 sins=sin(rotation);\n")
   +string(" vec2 coss=cos(rotation);\n")
   +string(" mat3 mr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n")
   +string(" mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;    \n")
   +string(" mat3 imr=mat3(vec3(coss.x,0.0,-sins.x),vec3(0.0,1.0,0.0),vec3(sins.x,0.0,coss.x));\n")
   +string(" imr=imr*mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,-sins.y),vec3(0.0,sins.y,coss.y));    \n")
   +string(" float t=time*1.0;	\n")
   +string(" vec3 ray = normalize(vec3(p,2.0));\n")
   +string(" vec3 pos = vec3(pos2d.x-0.5,pos2d.y-0.5,3.0); //0.0,0.0,3.0);    \n")
   +string(" float s1=starBody(ray,pos,1.0,mr,0.5,vec3(0.0),t);\n")
   +string(" s1=pow(min(1.0,s1*2.4),2.0);\n")
   +string(" float s2=starBody(ray,pos,1.0,mr,4.0,vec3(83.23,34.34,67.453),t);\n")
   +string(" s2=min(1.0,s2*2.2);\n")
   +string(" float zero=sphereZero(ray,pos,0.9);\n")
   +string("	vec4 col=vec4(0.0,0.0,0.0,1.0);\n")
   +string(" if (zero > 0.0) {\n")
   +string("  col = vec4( mix(surfaceStaticColor,surfaceStaticColor2,pow(s1,60.0))*s1, 1.0 );\n")
   +string(" } else {\n")
   +string("  col = vec4( convectiveColor + mix(surfaceStaticColor,surfaceStaticColor2,pow(s1,60.0))*s1, 1.0 );\n")
   +string(" }\n")
   +string(" col += vec4( mix(surfaceStaticColor,surfaceStaticColor2,pow(s1,60.0))*s1, 1.0 );\n")
   +string(" col += vec4( mix(mix(surfaceColor1,surfaceColor2,pow(s2,2.0)),vec3(1.0),pow(s2,10.0))*s2, 1.0 );	\n")
   +string(" col.xyz -= vec3(ring(ray,pos,1.03,11.0))*2.0;\n")
   +string(" col = max( vec4(0.0), col );    \n")
   +string(" float s3=max(ringRayNoise(ray,pos,rays_innerR,rays_outerR,mr,t),0.0);\n")
   +string(" col.xyz += mix(plasmaColor,coronaColor,pow(s3,3.0))*s3;\n")
   +string(" if (zero > 0.0) {\n")
   +string("	 vec4 s4=noiseSpace(ray,pos,100.0,mr,0.05,vec3(1.0,2.0,4.0),0.0);\n")
   +string("  s4.x=pow(s4.x,3.0);\n")
   +string("  col.xyz += mix(mix(windColor1,windColor2,s4.y*1.9),windColor3,s4.w*0.75)*s4.x*pow(s4.z*2.5,3.0)*0.2*zero;\n")
   +string(" }  \n")
   +string(" col = max( vec4(0.0), col );\n")
   +string("	col = min( vec4(1.0), col );\n")
   +string("	float circle = ( q.x * q.x + q.y * q.y ) * invCircleWidth;\n")
   +string(" outColor = (1.0-circle)*vec4( tintColor*col.xyz, (col.x+col.y+col.z)/3.0 );\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


  void ElectronCloudsShader::Init() {
  OUTPUT("ElectronCloudsShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")
   +string("uniform int iterations; // 4\n")
   +string("uniform float formuparam2; // 0.89\n")
   +string("uniform int volsteps; // 10\n")
   +string("uniform float stepsize; // 0.190\n")
   +string("uniform float zoom; // 3.900\n")
   +string("uniform float tile; //   0.450\n")
   +string("uniform float speed2; //  0.0010\n")
   +string("uniform float brightness; // 0.2\n")
   +string("uniform float darkmatter; // 0.400\n")
   +string("uniform float distfading; // 0.560\n")
   +string("uniform float saturation; // 0.400\n")
   +string("uniform float transverseSpeed; // 1.1\n")
   +string("uniform float cloud; //0.2\n")
   +string("uniform vec4 col1;\n")
   +string("uniform vec4 col2;\n")
   +string("uniform float time;\n")
   +string("uniform vec2 pos2d;\n")
   +string("uniform vec2 move2d;\n")
   +string("const float yAspect = 1080.0/1920;\n")
   +string("float triangle(float x, float a) {\n")
   +string(" float output2 = 2.0 * abs(3.0 * ((x / a) - floor((x / a) + 0.5))) - 1.0;\n")
   +string(" return output2;\n")
   +string("}\n")
   +string("float field(in vec3 p) {\n")
   +string(" float strength = 7.0 + 0.03 * log(1.e-6 + fract(sin(time) * 4373.11));\n")
   +string(" float accum = 0.;\n")
   +string(" float prev = 0.;\n")
   +string(" float tw = 0.; \n")
   +string(" for (int i = 0; i < 6; ++i) {\n")
   +string("  float mag = dot(p, p);\n")
   +string("  p = abs(p) / mag + vec3(-.5, -.8 + 0.1 * sin(time * 0.2 + 2.0), -1.1 + 0.3 * cos(time * 0.15));\n")
   +string("  float w = exp(-float(i) / 7.);\n")
   +string("  accum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n")
   +string("  tw += w;\n")
   +string("  prev = mag;\n")
   +string(" }\n")
   +string(" return max(0., 5. * accum / tw - .7);\n")
   +string("}\n")
   +string("void main() {\n")
   +string(" vec2 uv2 =  (Texcoord.xy * 2.0 - vec2(1.0) ) / vec2(2.0); uv2.y *= yAspect;\n")
   +string(" vec2 uvs = uv2;\n")
   +string(" float time1=time/100.0;\n")
   +string(" float time2 = time/10.0;\n")
   +string(" float speed = speed2;\n")
   +string(" float formuparam = formuparam2;\n")
   +string(" vec2 uv = uvs;\n")
   +string(" float a_xz = col2.x;// 0.9;\n")
   +string(" float a_yz = col2.y;//-.6;\n")
   +string(" float a_xy = col2.z /*0.9*/ + time*0.04;\n")
   +string(" mat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\n")
   +string(" mat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\n")
   +string(" mat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n")
   +string(" float v2 =1.0;\n")
   +string(" vec3 dir=vec3((uv*zoom)/2.0,1.);\n")
   +string(" vec3 from=vec3(pos2d + move2d,0.0) + vec3(123.45,432.101234,0.0);\n")
   +string(" from.x -= 5.0* (0.5);\n")
   +string(" from.y -= 5.0* (0.5);\n")
   +string(" vec3 forward = vec3(0.,0.,1.);\n")
   +string(" from.x += transverseSpeed*(1.0)*cos(0.01*time1/10.0) + 0.001*time1/10.0;\n")
   +string(" from.y += transverseSpeed*(1.0)*sin(0.01*time1/10.0) +0.001*time1/10.0;\n")
   +string(" from.z += 0.003*time1;\n")
   +string(" dir.xy*=rot_xy;\n")
   +string(" forward.xy *= rot_xy;\n")
   +string(" dir.xz*=rot_xz;\n")
   +string(" forward.xz *= rot_xz;\n")
   +string(" dir.yz*= rot_yz;\n")
   +string(" forward.yz *= rot_yz;\n")
   +string(" from.xy*=-rot_xy/10.0;\n")
   +string(" from.xz*=rot_xz/10.0;\n")
   +string(" from.yz*= rot_yz/10.0;\n")
   +string(" //zoom\n")
   +string(" float zooom = (time2-3311.)*speed;\n")
   +string(" from += forward*zooom;\n")
   +string(" float sampleShift = mod( zooom, stepsize );\n")
   +string(" float zoffset = -sampleShift;\n")
   +string(" sampleShift /= stepsize; // make from 0 to 1\n")
   +string(" //volumetric rendering\n")
   +string(" float s=0.24;\n")
   +string(" float s3 = s + stepsize/2.0;\n")
   +string(" vec3 v=vec3(0.);\n")
   +string(" float t3 = 0.0;\n")
   +string(" vec3 backCol2 = vec3(0.);\n")
   +string(" for (int r=0; r<volsteps; r++) {\n")
   +string("  vec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\n")
   +string("  vec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);// + vec3(0.,0.,zoffset);\n")
   +string("  p2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold\n")
   +string("  p3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\n")
   +string("  t3 = field(p3);\n")
   +string("  float pa,a=pa=0.;\n")
   +string("  for (int i=0; i<iterations; i++) {\n")
   +string("   p2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\n")
   +string("   //p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise\n")
   +string("   float D = abs(length(p2)-pa); // absolute sum of average change\n")
   +string("   if (i > 2) a += i > 7 ? min( 12., D) : D;\n")
   +string("   pa=length(p2);\n")
   +string("  }\n")
   +string("  a*=a*a; // add contrast\n")
   +string("  // brightens stuff up a bit\n")
   +string("  float s1 = s+zoffset;\n")
   +string("  float fade = pow(distfading,max(0.,float(r)-sampleShift));\n")
   +string("  v+=fade;\n")
   +string("  // fade out samples as they approach the camera\n")
   +string("  if( r == 0 ) fade *= (1. - (sampleShift));\n")
   +string("  // fade in samples as they approach from the distance\n")
   +string("  if( r == volsteps-1 )fade *= sampleShift;\n")
   +string("  v+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n")
   +string("  backCol2 += mix(.4, 1., v2) * vec3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade;\n")
   +string("  s+=stepsize;\n")
   +string("  s3 += stepsize;\n")
   +string(" }\n")
   +string(" v=mix(vec3(length(v)),v,saturation);\n")
   +string(" vec4 forCol2 = vec4(v*.01,1.);\n")
   +string(" backCol2 *= cloud;\n")
   +string(" outColor = col1 + forCol2 + vec4(backCol2, 1.0);\n")
   +string("}")
  ;
  loadShaders(vert.c_str(),frag.c_str());
  InitUniforms();
 }


  void ClassicPlanetShader::Init() {
  OUTPUT("ClassicPlanetShader::Loading\n");
  string vert=
    string("#version 330\n")
   +string("in vec2 position;\n")
   +string("in vec2 texcoord;\n")
   +string("uniform mat4 trans;\n")
   +string("out vec2 Texcoord;\n")
   +string("\n")
   +string("void main() {\n")
   +string(" Texcoord = texcoord;\n")
   +string(" gl_Position = trans * vec4(position, 0.0, 1.0);\n")
   +string("}")
  ;
  string frag=
    string("#version 330 core\n")
   +string("in vec2 Texcoord;\n")
   +string("out vec4 outColor;\n")+
    string("uniform vec2 pos2d;\n")
   +string("uniform sampler2D tex1;\n")
   +string("uniform sampler2D tex2;\n")
   +string("uniform sampler2D tex3;\n")
   +string("uniform sampler2D tex4;\n")
   +string("uniform float seed; //=0.0;\n")
   +string("uniform vec4 sF; //=vec4(1.0,100.0,90.0,45.0);\n")
   +string("uniform vec4 nT; //=vec4(2.0,3.0,4.0,5.0);\n")
   +string("uniform vec2 striations; //=vec2(0.0,0.8);\n")
   +string("uniform vec4 noiseform; //=vec4(3.0,2.0,3.0,2.0);\n")
   +string("uniform vec4 nf2; //=vec4(4.0,8.0,0.66,0.34);\n")
   +string("uniform vec4 nf3; //=vec4(0,41,289,330);\n")
   +string("uniform vec2 nf5; //=vec2(10.0,0.5);\n")
   +string("uniform float edgeGlow; //=0.001;\n")
   +string("uniform float noisescale; //=0.005;\n")
   +string("uniform vec4 colMixer; //=vec4(0.5,0.5,0.5,0.5);\n")
   +string("uniform vec3 colorA; //=vec3(0.15, 0.05, 1);\n")
   +string("uniform vec3 colorB; //=vec3(1., 0.1, 0.02);\n")
   +string("uniform vec2 e; // = vec2(0.1001, 0); \n")
   +string("uniform vec2 nf4; //=vec2(12., 48.);\n")
   +string("float rand(float n){return fract(sin(n) * 43758.5453123);}\n")
   +string("float rand(vec2 c){return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);}\n")
   +string("float valueNoise2D(vec2 p, float t) {\n")
   +string(" vec2 f = fract(p); // Fractional cell position.\n")
   +string(" f *= f*(noiseform.z-noiseform.w*f);// Smooth step\n")
   +string(" vec4 h = fract(sin(nf3 + dot(floor(p), nf3.yz))*43758.5453);\n")
   +string(" h = cos(h*6.283 + t)*0.5 + 0.5; // Animation.\n")
   +string(" return dot(vec2(1.0-f.y, f.y), vec2(1.0-f.x, f.x)*mat2(h));\n")
   +string("}\n")
   +string("float func2D(vec2 p, float t){ return valueNoise2D(p*nf2.x,t)*nf2.z + valueNoise2D(p*nf2.y,t)*nf2.w; }\n")
   +string("float smoothFract(float x, float sf){\n")
   +string("    x = fract(x);\n")
   +string("    return min(x, x*(1.-x)*sf);\n")
   +string("}\n")
   +string("vec4 noise2d( in vec2 coord, float t ) {\n")
   +string(" vec2 uv = coord.xy * noisescale;\n")
   +string(" float f = func2D(uv,t); // Range [0, 1]\n")
   +string(" float g = length( vec2(f - func2D(uv-e.xy,t), f - func2D(uv-e.yx,t)) )/(e.x);\n")
   +string(" g = f/max(g, edgeGlow);\n")
   +string(" float c = smoothFract(f*noiseform.x, g/noiseform.y); // Range [0, 1]\n")
   +string(" vec3 col = vec3(c);\n")
   +string(" f = f*noiseform.x;\n")
   +string(" float tx = smoothstep(striations.x,striations.y, (func2D((uv + (1. - c)*.01)*nf4,t))); // Range: [0, 1]\n")
   +string(" if(f>nT.x && f<nT.y) col *= colorB*(tx); // Red.\n")
   +string(" else if(f>nT.z && f<nT.w) col *= colorA*(tx); // Blue.\n")
   +string(" else col *= abs(tx - .5)*.4 + .8; // White.\n")
   +string(" col += min(g*g*g*g*.1, 1.)*(1.-col);\n")
   +string(" return vec4(sqrt(clamp(col, 0., 1.)), 1.0 );\n")
   +string("}\n")
   +string("float noise(vec2 n) {\n")
   +string(" const vec2 d = vec2(0.0, 1.0);\n")
   +string(" vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n")
   +string(" return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n")
   +string("}\n")
   +string("void main()\n")
   +string("{\n")
   +string(" vec2 uv = pos2d.xy + Texcoord.xy;\n")
   +string(" vec4 col1,col2,col3,col4,col5,col6;\n")
   +string(" col5=noise2d(uv*nf5.x,seed);\n")
   +string(" col6=vec4(noise(uv*nf5.y)); col6.a=1.0;\n")
   +string(" col1=texture2D(tex1,uv/sF.x);\n")
   +string(" col2=texture2D(tex2,uv/sF.y)*(col5+col6)/2.0;\n")
   +string(" col3=texture2D(tex3,uv/sF.z)+col5;\n")
   +string(" col4=texture2D(tex4,uv/sF.w)*colMixer.w;\n")
   +string(" if ( col3.r < 15.0/255.0 && col3.r > 0.0 ) col2/=col5.r;\n")
   +string(" vec4 col=vec4(0,0,0,1.);\n")
   +string(" if ( col3.r > colMixer.x ) col=col1;\n")
   +string(" else col=col1;\n")
   +string(" if ( col4.r > colMixer.y ) col=col2;\n")
   +string(" else col+=col4;\n")
   +string(" vec4 fcol=mix(col,col5,colMixer.z);\n")
   +string(" fcol.a=1.0;\n")
   +string(" outColor=fcol;\n")
   +string("}\n")
   +string("\n")
  ;
  Strings binds; binds.Add("outColor");
  loadShaders(&binds,vert.c_str(),frag.c_str());
  InitUniforms();
 }